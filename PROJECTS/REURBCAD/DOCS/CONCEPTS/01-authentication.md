Authentication no REURBCAD mobile usa OAuth2 Authorization Code + PKCE flow adaptado para mobile onde app abre browser nativo (não webview) via react-native-app-auth ou expo-auth-session, browser navega para Keycloak login screen mantendo session cookies isolados do app aumentando segurança, usuário faz login com credenciais, Keycloak gera authorization code, redirect via deep link com scheme com.carf.reurbcad://oauth/callback, app recebe deep link event via Linking.addEventListener('url', handleDeepLink), extrai code da URL query params, library automaticamente exchange code por tokens fazendo POST ao /protocol/openid-connect/token com grant_type=authorization_code, client_id=reurbcad, code, code_verifier (PKCE), redirect_uri, recebe JSON response { access_token, id_token, refresh_token, expires_in, refresh_expires_in }.

Armazena refresh_token em SecureStore com await SecureStore.setItemAsync('refresh_token', refreshToken) usando encryption via Keychain (iOS) ou Keystore (Android), mantém accessToken e expiresAt em memória como class properties do AuthService, parseUser() method decodifica accessToken JWT extraindo claims atob(token.split('.')[1]) obtendo { sub, email, name, tenant_id, allowed_tenants, realm_access.roles }, token refresh implementado em getAccessToken() que checa if (Date.now() < this.expiresAt - 60000) retorna cached accessToken caso contrário faz refresh chamando POST /protocol/openid-connect/token com grant_type=refresh_token, client_id=reurbcad, refresh_token obtendo novo accessToken atualizando this.accessToken e this.expiresAt, se refresh falha (offline token expirado após 30 dias) chama logout() limpando tokens e redirecionando para login, session restoration no app startup via restoreSession() que tenta obter refresh_token do SecureStore, se existe tenta refresh para validar, se sucesso popula user state e considera authenticated=true, se falha ou token não existe mostra login screen.

Offline_access scope crítico para obter offline refresh token com validade estendida (30 dias idle, 60 dias max) configurado no Keycloak realm permitindo field collectors trabalhar semanas sem re-login mesmo offline porque quando voltam online refresh ainda válido, logout implementado com revoke(config, { tokenToRevoke: refreshToken }) fazendo POST ao /protocol/openid-connect/revoke invalidando token no server side, depois limpa SecureStore com deleteItemAsync('refresh_token') e seta this.accessToken = null, this.refreshToken = null.

API integration usa interceptor Axios que antes de request chama accessToken = await AuthService.getAccessToken() garantindo token válido e adiciona Authorization: Bearer ${accessToken}, se response 401 tenta refresh uma vez, se falha novamente força logout, network offline handling onde se NetInfo.isConnected=false API calls são queued localmente em AsyncStorage com pending_requests array cada item { url, method, body, headers, timestamp }, quando conexão restabelecida processa queue sequencialmente retry failed requests com exponential backoff.
