Conceitos fundamentais do REURBCAD incluindo Offline-First architecture onde app funciona completamente offline armazenando dados localmente em WatermelonDB SQLite, sincronizando apenas quando conexão detectada via NetInfo.addEventListener('change', handleConnectivityChange), UI permanece responsiva mesmo offline com feedback visual indicando status sync pending/syncing/synced, WatermelonDB ORM reativo que provê models como Occupation, Holder, Photo com @field decorators, observeWithColumns() para reactivity automática re-rendering components quando dados mudam, batch operations para performance, lazy loading de relationships via @relation, queries otimizadas com índices SQLite, OAuth2 Mobile adaptações onde Authorization Code + PKCE flow usa browser nativo não webview por segurança (Apple ASWebAuthenticationSession, Android Chrome Custom Tabs), deep links para callback recebendo authorization code, PKCE sem client secret porque mobile app não pode armazenar secrets seguramente (decompilação APK/IPA expõe), offline_access scope para refresh tokens de longa duração (30 dias) permitindo sync background sem re-login frequente, Secure Token Storage usando Keychain (iOS encrypted via Secure Enclave) e Keystore (Android encrypted via hardware-backed keystore) através de expo-secure-store ou react-native-keychain, nunca AsyncStorage porque plain text acessível via device backup ou root access, GPS Tracking com expo-location ou react-native-geolocation-service configurado para accuracy HIGH (GPS + WiFi + cellular), background mode para tracking contínuo durante coleta, permission requests explicando why app precisa location (Android manifest FINE_LOCATION, iOS Info.plist NSLocationWhenInUseUsageDescription), coordenadas salvadas com cada Occupation como latitude/longitude decimal degrees WGS84, Camera Integration via expo-camera ou react-native-image-picker com quality compression (0.7) para reduzir tamanho mantendo legibilidade, EXIF data preservado incluindo GPS coordinates se available, photos armazenadas localmente em filesystem com path salvo em WatermelonDB, upload assíncrono quando online via multipart/form-data, Synchronization Strategy pull-first (fetch remote changes) depois push (send local changes) para minimizar conflicts, incremental sync via lastPulledAt timestamp enviado ao backend que retorna apenas changes since timestamp, conflict resolution via three-way merge comparando local.updated_at vs remote.updated_at vs base.updated_at usando last-write-wins (remote sempre ganha se mais recente) ou manual resolution UI mostrando diff side-by-side, sync queue para retry failed syncs quando conexão restabelecida, Network Detection via NetInfo listener checando isConnected e isInternetReachable antes de tentar sync evitando timeout errors, exponential backoff retry strategy (1s, 2s, 4s, 8s) se sync falha temporariamente, Navigation Stack flow linear para coleta sequencial ListOccupations → CreateOccupation (formulário) → CapturePhotos (câmera múltiplas fotos) → ReviewData (preview antes submit) → Confirmation (sucesso feedback), back button handling com confirmação "Descartar mudanças?" se formulário partially filled, deep linking para abrir occupation específica via notification tap, State Management distribuído com React Context para auth state global (user, isAuthenticated, tokens), WatermelonDB observers para data reactivity (occupations.observe() retorna Observable que re-renders component automaticamente), useState para UI local state (form inputs, modal open), no Redux/MobX porque adiciona complexidade desnecessária quando WatermelonDB já provê reactivity, Performance Optimization com FlashList ao invés de FlatList para listas longas (10x faster rendering), Image caching via react-native-fast-image, lazy loading de photos apenas quando visíveis, memoization de components pesados com React.memo(), useMemo() para computed values caros, batch updates de WatermelonDB com database.write() wrapping múltiplas operações em single transaction, e Error Handling com try/catch em async operations, Error Boundary para runtime errors, Sentry integration para crash reporting produção, toast notifications para user feedback visual, console.error para debugging local com react-native-debugger.
