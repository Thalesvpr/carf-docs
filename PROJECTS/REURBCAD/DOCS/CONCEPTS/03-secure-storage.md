Secure storage no REURBCAD usa expo-secure-store (Expo) ou react-native-keychain (bare RN) para armazenar refresh_token encrypted via hardware-backed security modules Keychain (iOS) e Keystore (Android) nunca AsyncStorage porque plain text acessível via device backup, root/jailbreak, ou malware, Keychain iOS implementation usa kSecAttrAccessible com kSecAttrAccessibleAfterFirstUnlock permitindo acesso após device unlock primeira vez garantindo availability mas mantendo encryption at rest, data encrypted via AES-256-GCM usando key derivada do device hardware UID + user passcode no Secure Enclave (A7+ chips) que é hardware security module tamper-resistant não acessível via software mesmo com root, se device não tem Secure Enclave (older devices) usa software-based encryption menos seguro mas ainda melhor que plain text, Keystore Android implementation usa Android KeyStore system que armazena cryptographic keys em TEE (Trusted Execution Environment) ou StrongBox (hardware security module em Pixel 3+), keys nunca exported do KeyStore garantindo que decryption acontece apenas dentro do secure hardware, encryption algorithm RSA-2048 ou AES-256-GCM dependendo API level e hardware support, biometric authentication integration opcional via expo-local-authentication antes de acessar SecureStore adicionando layer extra exigindo fingerprint/face antes de ler refresh_token, usage pattern ao salvar token após login success `await SecureStore.setItemAsync('refresh_token', refreshToken, { keychainAccessible: SecureStore.AFTER_FIRST_UNLOCK })` com options especificando accessibility level, ao restaurar sessão app startup `const refreshToken = await SecureStore.getItemAsync('refresh_token')` que retorna null se não existe ou string encrypted se existe, ao logout `await SecureStore.deleteItemAsync('refresh_token')` que remove permanentemente do Keychain/Keystore, error handling try/catch porque setItemAsync pode falhar se storage full (raro) ou device encryption disabled (user setting), nunca armazenar access_token em SecureStore porque dura apenas 5 min e overhead de encryption/decryption desnecessário, manter em memória como class property que é wiped quando app killed pelo OS, data além de tokens como user preferences, theme settings podem usar AsyncStorage porque não sensitive, mas tenant_id e user_id sensíveis também devem usar SecureStore ou pelo menos encrypt via crypto library antes AsyncStorage, backup considerations iOS iCloud Keychain backup inclui Keychain items por padrão mas kSecAttrAccessibleAfterFirstUnlock items são excluded garantindo refresh_token não vazado via backup, Android KeyStore items nunca backed up automaticamente protegendo tokens, migration de AsyncStorage para SecureStore em app update requer ler tokens de AsyncStorage, salvar em SecureStore, deletar de AsyncStorage via database.clear() evitando deixar tokens plain text após migration.
