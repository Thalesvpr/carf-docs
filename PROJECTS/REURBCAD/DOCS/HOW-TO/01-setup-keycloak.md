Setup Keycloak no REURBCAD requer primeiro instalar dependencies com `npm install react-native-app-auth` (bare RN) ou usar expo-auth-session (Expo managed), criar .env com KEYCLOAK_URL=http://localhost:8080, KEYCLOAK_REALM=carf, KEYCLOAK_CLIENT_ID=reurbcad, API_URL=http://localhost:5000, configurar deep link scheme em app.json (Expo) adicionando "scheme": "com.carf.reurbcad" dentro de expo object, ou AndroidManifest.xml (bare) adicionando <intent-filter> dentro de <activity android:name=".MainActivity"> com <action android:name="android.intent.action.VIEW" />, <category android:name="android.intent.category.DEFAULT" />, <category android:name="android.intent.category.BROWSABLE" />, <data android:scheme="com.carf.reurbcad" android:host="oauth" android:pathPrefix="/callback" />, e Info.plist (iOS bare) adicionando <key>CFBundleURLTypes</key> array com <dict> contendo <key>CFBundleURLSchemes</key> array com <string>com.carf.reurbcad</string>, criar src/services/AuthService.ts com config object { issuer: process.env.KEYCLOAK_URL + '/realms/' + process.env.KEYCLOAK_REALM, clientId: process.env.KEYCLOAK_CLIENT_ID, redirectUrl: 'com.carf.reurbcad://oauth/callback', scopes: ['openid', 'profile', 'email', 'offline_access'] }, implementar login() method com `const result = await authorize(config)` (react-native-app-auth) que abre browser, usuário faz login, retorna { accessToken, idToken, refreshToken, accessTokenExpirationDate }, armazenar tokens com `await SecureStore.setItemAsync('refresh_token', result.refreshToken)`, manter accessToken e expiresAt em memória como class properties, implementar getAccessToken() que checa if (Date.now() < this.expiresAt - 60000) retorna cached accessToken senão faz refresh com `const result = await refresh(config, { refreshToken: this.refreshToken })` atualizando tokens, implementar logout() com `await revoke(config, { tokenToRevoke: this.refreshToken })` depois `await SecureStore.deleteItemAsync('refresh_token')`, implementar restoreSession() chamado no app startup tentando `const refreshToken = await SecureStore.getItemAsync('refresh_token')` se existe tenta getAccessToken() para validar retornando true se sucesso false se falha, criar src/contexts/AuthContext.tsx com AuthProvider component que em useEffect chama `restoreSession().then(authenticated => setIsAuthenticated(authenticated)).finally(() => setIsLoading(false))`, provider value exporta { user, isAuthenticated, isLoading, login, logout, getAccessToken }, em App.tsx importar AuthProvider e wrap `<AuthProvider><Navigation /></AuthProvider>`, configurar navigation em src/navigation/index.tsx criando stack navigator com createNativeStackNavigator(), conditional rendering `{isAuthenticated ? <AppStack /> : <AuthStack />}` onde AppStack tem screens protegidas e AuthStack tem LoginScreen, criar LoginScreen com Button onPress={login} title="Entrar com Keycloak", testar iniciando Keycloak local docker-compose up -d, verificando realm carf e client reurbcad configurado com Valid Redirect URIs incluindo com.carf.reurbcad://oauth/callback e Web Origins +, Public Client ON, Standard Flow Enabled ON, PKCE Code Challenge Method S256, criar user teste via Admin Console com username, email, password temporary OFF, attributes tenants=[\"prefeitura-teste\"], current_tenant=[\"prefeitura-teste\"], role mappings field-collector, iniciar app com `npx react-native run-android` ou `npx expo start`, tap botão Login, observar browser abrindo para Keycloak login, fazer login com user teste, observar redirect de volta para app via deep link, verificar logs "Token validated for user..." indicando sucesso, verificar SecureStore contém refresh_token com `SecureStore.getItemAsync('refresh_token').then(console.log)`, testar token refresh fechando app, esperando 6+ minutos para access_token expirar, reabrindo app, verificar que restoreSession() sucede fazendo refresh automático.
