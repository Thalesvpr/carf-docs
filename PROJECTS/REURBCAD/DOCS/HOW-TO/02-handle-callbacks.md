Handle OAuth callbacks no REURBCAD requer configurar deep link listeners para receber authorization code após usuário fazer login no Keycloak browser, react-native-app-auth e expo-auth-session fazem isso automaticamente mas entender mecanismo útil para debugging, deep link flow consiste em app faz authorize(config) que abre browser nativo navegando para http://localhost:8080/realms/carf/protocol/openid-connect/auth com query params incluindo redirect_uri=com.carf.reurbcad://oauth/callback, usuário completa login, Keycloak gera authorization code, Keycloak redirect browser para redirect_uri com code e state params como com.carf.reurbcad://oauth/callback?code=abc123&state=xyz789, OS detecta deep link scheme com.carf.reurbcad e lança app se não running ou traz para foreground se já running, app recebe deep link event via Linking API, react-native-app-auth library automaticamente extrai code da URL query, valida state param matches original para prevenir CSRF attacks, faz POST ao token endpoint com grant_type=authorization_code, client_id, code, code_verifier (PKCE), redirect_uri, recebe tokens response, retorna promise que resolve com { accessToken, refreshToken, etc }, manual implementation sem library requer Linking.addEventListener('url', handleDeepLink) onde handleDeepLink = (event) => { const { url } = event; const params = extractParams(url); if (params.code && params.state === expectedState) { exchangeCodeForTokens(params.code).then(tokens => storeTokens(tokens)) } }, extractParams helper parsa URL query string com const url = new URL(event.url); const searchParams = new URLSearchParams(url.search); return { code: searchParams.get('code'), state: searchParams.get('state') }, state validation critical para security gerando random string antes de authorize armazenando em memory ou AsyncStorage, verificando que returned state matches expected prevenindo CSRF onde attacker tricks user em clicking malicious deep link com different code, exchangeCodeForTokens implementation faz fetch ao token endpoint POST http://localhost:8080/realms/carf/protocol/openid-connect/token com body form-urlencoded grant_type=authorization_code, client_id=reurbcad, code=abc123, code_verifier=original_verifier, redirect_uri=com.carf.reurbcad://oauth/callback, parse JSON response extraindo access_token, refresh_token, expires_in, armazenando tokens via SecureStore, deep link testing Android usa adb shell am start com intent flags -a android.intent.action.VIEW -d "com.carf.reurbcad://oauth/callback?code=test123" abrindo app com mock code útil para testar callback handling sem fazer login real, iOS usa xcrun simctl openurl booted "com.carf.reurbcad://oauth/callback?code=test123" no simulator, production considerations deep link só funciona se app instalado caso contrário browser mostra erro "Page not found", alguns browsers Android mostram interstitial "Open with REURBCAD app?" exigindo user confirmation, iOS ASWebAuthenticationSession não mostra interstitial porque sistema nativo, error handling se callback never received porque user fechou browser antes de completar login então promise de authorize() fica pending indefinitely, adicionar timeout com Promise.race([authorize(config), timeout(30000)]) onde timeout retorna rejection após 30s, catch block mostra "Login cancelado" toast notification, multiple callbacks edge case se user taps back button browser depois forward pode gerar múltiplos deep links com mesmo code, code pode ser used apenas uma vez no Keycloak então segundo callback falha com "Code already used", mitigação tracking if (codeExchangeInProgress) return early prevenindo duplicate exchanges.
