AuthService layer encapsula toda lógica OAuth2 mobile em src/services/AuthService.ts como singleton class com private constructor garantindo single instance shared globalmente, config object define { issuer: KEYCLOAK_URL + '/realms/carf', clientId: 'reurbcad', redirectUrl: 'com.carf.reurbcad://oauth/callback', scopes: ['openid', 'profile', 'email', 'offline_access'] } com offline_access critical para obter long-lived refresh token, class properties private accessToken: string | null, private refreshToken: string | null, private expiresAt: number | null armazenando tokens em memória, login() method async implementa `const result = await authorize(config)` de react-native-app-auth que abre ASWebAuthenticationSession (iOS) ou Chrome Custom Tabs (Android), usuário faz login Keycloak, retorna { accessToken, idToken, refreshToken, accessTokenExpirationDate } parseando expirationDate string para timestamp, chama this._storeTokens(result) que executa `await SecureStore.setItemAsync('refresh_token', result.refreshToken)` armazenando encrypted via Keychain/Keystore, seta this.accessToken = result.accessToken, this.expiresAt = new Date(result.accessTokenExpirationDate).getTime(), chama this._loadUserInfo() que decodifica JWT parseando base64 payload extraindo claims sub, email, name, tenant_id, allowed_tenants, roles retornando User object, getAccessToken() method checa if (Date.now() < this.expiresAt - 60000) retorna this.accessToken cached porque ainda válido por mais de 1 minuto, caso contrário if (!this.refreshToken) throw Error('No refresh token') prevenindo refresh sem token, faz `const result = await refresh(config, { refreshToken: this.refreshToken })` POST ao token endpoint com grant_type=refresh_token obtendo novo accessToken, chama this._storeTokens(result) atualizando tokens e expiresAt, retorna novo accessToken, catch block se refresh falha chama this.logout() limpando tokens e lançando error forçando re-login, logout() method faz `await revoke(config, { tokenToRevoke: this.refreshToken, tokenTypeHint: 'refresh_token' })` POST ao revoke endpoint invalidando token server-side, depois `await SecureStore.deleteItemAsync('refresh_token')` removendo de Keychain/Keystore, seta this.accessToken = null, this.refreshToken = null, this.expiresAt = null, lança AuthLogoutEvent para listeners notificarem UI update, restoreSession() method chamado app startup tenta `const refreshToken = await SecureStore.getItemAsync('refresh_token')` se null retorna false indicando no session, se exists seta this.refreshToken = refreshToken, chama this.getAccessToken() que fará refresh automático validando token, se sucesso retorna true authenticated, se falha retorna false forçando login, switchTenant() method recebe tenantId string valida se está em allowed_tenants array, faz fetch POST ao backend /api/auth/switch-tenant com Authorization header obtido via this.getAccessToken(), backend atualiza current_tenant attribute Keycloak user, força refresh com this.expiresAt = 0 bypass cache chamando this.getAccessToken() obtendo novo token com tenant_id claim atualizado, retorna success, usage pattern em screens `const authService = AuthService.getInstance()` obtendo singleton, ao login button tap `await authService.login().then(user => navigation.replace('Home')).catch(err => Alert.alert('Erro', err.message))`, API client Axios interceptor request adiciona `config.headers.Authorization = 'Bearer ' + await AuthService.getInstance().getAccessToken()` automaticamente antes de cada request garantindo token válido refreshando se necessário, interceptor response se status 401 tenta refresh uma vez, se falha força logout redirecionando para login.
