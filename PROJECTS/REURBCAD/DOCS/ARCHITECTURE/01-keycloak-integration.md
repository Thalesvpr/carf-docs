REURBCAD integra Keycloak mobile usando react-native-app-auth (bare RN) ou expo-auth-session (Expo) implementando OAuth2 Authorization Code + PKCE flow iniciando com configuração de deep link scheme em app.json (Expo) adicionando "scheme": "com.carf.reurbcad" ou AndroidManifest.xml (bare) com intent-filter action VIEW category BROWSABLE DEFAULT data scheme="com.carf.reurbcad" host="oauth" pathPrefix="/callback" e Info.plist (iOS) com CFBundleURLTypes array contendo CFBundleURLSchemes com.carf.reurbcad, AuthService class encapsula lógica OAuth criando config object { issuer: KEYCLOAK_URL + '/realms/carf', clientId: 'reurbcad', redirectUrl: 'com.carf.reurbcad://oauth/callback', scopes: ['openid', 'profile', 'email', 'offline_access'] } onde offline_access scope crítico para obter refresh token de longa duração permitindo sync background.

Login() method chama authorize(config) que abre browser nativo via ASWebAuthenticationSession (iOS) ou Chrome Custom Tabs (Android) navegando para Keycloak login screen, usuário faz login, Keycloak gera authorization code, redirect de volta para app via deep link com code, library automaticamente exchange code por tokens enviando code_verifier para PKCE validation, retorna { accessToken, idToken, refreshToken, accessTokenExpirationDate }, armazena tokens com SecureStore.setItemAsync('refresh_token', refreshToken) nunca AsyncStorage porque plain text inseguro, mantém accessToken e expiresAt em memória (class properties), getAccessToken() method checa if (Date.now() < expiresAt - 60000) retorna accessToken cached caso contrário faz refresh chamando refreshToken via refresh(config, { refreshToken }) obtendo novo accessToken atualizando expiresAt e opcionalmente novo refreshToken, se refresh falha (offline token expirou após 30 dias) força logout redirecionando para login.

Logout() method chama revoke(config, { tokenToRevoke: refreshToken }) invalidando token no Keycloak depois limpa tokens local com SecureStore.deleteItemAsync(), restoreSession() method chamado no app startup tenta obter refresh_token do SecureStore, se existe tenta refresh para obter accessToken válido, se sucesso usuário já logado, se falha força login, API calls usam interceptor que adiciona Authorization header obtendo token com await AuthService.getAccessToken() antes de cada request, se request retorna 401 tenta refresh uma vez, se falha novamente força logout.

Tenant switching implementado fazendo POST /api/auth/switch-tenant no backend com novo tenantId, backend valida allowed_tenants claim e atualiza current_tenant no Keycloak, frontend força refresh com getAccessToken() passando flag para bypass cache obtendo novo token com tenant_id claim atualizado, limpa WatermelonDB local com database.write(async () => { await database.unsafeResetDatabase() }) para evitar mixing de dados de diferentes tenants, re-sincroniza dados do novo tenant via syncData(), e offline tokens critical porque field collectors trabalham áreas sem internet então refresh token deve durar 30 dias configurado no Keycloak realm settings Offline Session Idle: 30 days permitindo sync quando voltam para área com conexão.

---

**Última atualização:** 2026-01-15
**Status do arquivo**: Incompleto
Descrição: Falta título H1 na primeira linha.
