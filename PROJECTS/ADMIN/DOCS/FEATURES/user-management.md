# User Management - Gestão de Usuários

Feature de gestão de usuários implementada como proxy frontend para Keycloak Admin API permitindo ADMIN e super-admin criar visualizar editar desativar usuários configurar roles attributes tenants sem necessidade de acessar Keycloak Admin Console diretamente através de páginas UsersListPage exibindo grid paginado com search filters por email username role tenant status usando TanStack Query useQuery hook chamando GET /api/admin/users que internamente chama Keycloak Admin API GET /admin/realms/carf/users com confidential client usando client_secret, UserFormPage modal para criar e editar users com formulário React Hook Form validando campos username email firstName lastName cpf tenants current_tenant roles via Zod schema, UserDetailsPage exibindo tabs Info Attributes Roles Sessions mostrando dados completos user profile, componentes principais UserCard exibindo avatar nome email roles badges tenant switcher, UserTable com Tanstack Table sorting filtering pagination, AssignRolesModal listando available realm roles field-collector analyst manager admin super-admin com checkboxes multi-select, EditAttributesModal permitindo adicionar modificar remover custom attributes tenants array current_tenant string cpf validated via CPF helper, ChangePasswordModal forçando update password com validações strength requirements.

Validações implementadas via Zod schemas userSchema validando username obrigatório unique async validator debounced chamando GET /api/admin/users/validate-username retornando boolean exists comparando com existing users excluindo current user se editing, email obrigatório formato válido regex pattern unique validator, firstName lastName obrigatórios strings trim min 2 max 100, cpf opcional mas se preenchido valida formato via custom Zod refine chamando @carf/tscore validateCPF helper checando dígitos verificadores, password obrigatório na criação opcional na edição min 12 chars regex requiring uppercase lowercase digit special char matching realm password policy configurado Keycloak, tenants obrigatório array min 1 UUID cada validando formato e existência via GET /api/tenants verificando IDs válidos do sistema, current_tenant obrigatório UUID validando presente em tenants array garantindo consistência, roles obrigatório array min 1 enum validating against available realm roles, attributes optional object key value pairs validando keys alphanumeric underscore apenas values strings max 500 chars, validação client-side onChange mostrando inline errors, validação server-side repetindo checks backend antes de chamar Keycloak API rejeitando requests inválidos.

API integration implementada via backend proxy GEOAPI endpoints /api/admin/users wrapping Keycloak Admin API calls usando kcAdmin library @keycloak/keycloak-admin-client inicializado com client_id admin-client client_secret obtido Azure Key Vault AWS Secrets Manager nunca hardcoded, endpoints implementados GET /api/admin/users paginação via query params first max returning users array total count, GET /api/admin/users/:id retornando single user complete profile attributes roles sessions, POST /api/admin/users criando user via kcAdmin.users.create payload username email firstName lastName enabled true temporary false retornando userId depois setando password via kcAdmin.users.resetPassword id userId value password temporary false, PATCH /api/admin/users/:id atualizando fields via kcAdmin.users.update id fields partial, DELETE /api/admin/users/:id desativando via update enabled false soft delete preservando data, POST /api/admin/users/:id/roles atribuindo roles via kcAdmin.users.addRealmRoleMappings id roles array, DELETE /api/admin/users/:id/roles removendo roles via deleteRealmRoleMappings, PATCH /api/admin/users/:id/attributes atualizando attributes object via update merging com existing, custom hooks useUsers useCreateUser useUpdateUser useDeleteUser encapsulando TanStack Query mutations com error handling retry logic optimistic updates cache invalidation, Authorization header com Bearer token do admin user fazendo request validando permissions super-admin ou admin role antes de proxy calls.

Domain model mapeando Keycloak user representation para CENTRAL User entity com properties id UUID username unique email unique firstName lastName enabled boolean attributes object contendo tenants string array cpf string current_tenant string custom fields, roles array de strings realm roles field-collector analyst manager admin super-admin, sessions array de UserSessionRepresentation mostrando active sessions ipAddress lastAccess, implementação security requirements incluindo RBAC verificando user roles via hasRole helper condicionalmente renderizando create edit delete actions, RLS não aplicável porque Keycloak dados não PostgreSQL mas backend endpoints validam tenant_id do authenticated user antes de retornar users list filtrando apenas users do mesmo tenant exceto super-admin vendo all tenants, auditoria todas operações user create update delete roles change logged backend audit_log table com actor action timestamp details JSON incluindo user_id affected fields para compliance LGPD rastreabilidade, relacionamento CENTRAL Security concepts implementando authentication via Keycloak authorization RBAC multi-tenancy via attributes user lifecycle management requirements rastreando RF-001 RF-002 RF-003 autenticação autorização gestão usuários.

---

**Última atualização:** 2026-01-11
