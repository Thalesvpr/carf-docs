Authentication no GEOWEB usa keycloak-js library que gerencia OAuth2 Authorization Code + PKCE flow automaticamente onde usuário acessa app, é redirecionado para Keycloak login screen se não autenticado via keycloak.init({ onLoad: 'login-required' }), faz login com credenciais, Keycloak gera authorization code com PKCE code_challenge, redirect de volta para app com code na URL, keycloak-js automaticamente troca code por tokens enviando code_verifier, recebe access_token (JWT válido 5 minutos), id_token (perfil usuário), refresh_token (renovação sem re-login válido conforme sessão SSO 30min idle/10h max), armazena tokens em memória não localStorage prevenindo XSS attacks, popula keycloak.authenticated=true, keycloak.token com access token string, keycloak.tokenParsed com claims decoded (sub, email, tenant_id, roles), AuthContext wrapper React provê interface limpa com useAuth() hook retornando { user, isAuthenticated, login, logout, getToken }, setupTokenRefresh() em AuthContext configura setInterval de 240000ms (4 minutos) que chama keycloak.updateToken(60) checando se token expira em menos de 60 segundos e se sim faz POST ao /protocol/openid-connect/token com grant_type=refresh_token e refresh_token obtendo novo access_token atualizando keycloak.token, se refresh falha (sessão SSO expirou) chama keycloak.login() redirecionando para login novamente, logout chama keycloak.logout({ redirectUri: window.location.origin }) que faz GET ao /protocol/openid-connect/logout invalidando sessão SSO fazendo logout de todas as 6 aplicações CARF simultaneamente (GEOWEB, REURBCAD, GEOAPI, GEOGIS, WEBDOCS, ADMIN) e redirect de volta para origin, token usage em API calls via Axios interceptor que antes de cada request chama await keycloak.updateToken(5) garantindo token válido e adiciona `Authorization: Bearer ${keycloak.token}` no header, se backend retorna 401 com "Token is not active" interceptor response detecta e chama keycloak.login() forçando re-autenticação.
