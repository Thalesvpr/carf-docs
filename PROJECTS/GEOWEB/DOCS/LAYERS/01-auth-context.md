AuthContext layer implementado em src/shared/lib/auth/ como cross-cutting concern disponível para todas features, consiste em AuthContext.tsx criando React Context com createContext<AuthContextType | undefined>(undefined) onde AuthContextType interface define { isAuthenticated: boolean, isLoading: boolean, user: User | null, login: () => void, logout: () => void, switchTenant: (tenantId: string) => Promise<void>, hasRole: (roles: string[]) => boolean, getToken: () => Promise<string> }, AuthProvider component function recebe { children } props, mantém state [isAuthenticated, setIsAuthenticated], [isLoading, setIsLoading], [user, setUser] usando useState hooks.

UseEffect(() => { initKeycloak() }, []) executa uma vez no mount chamando async initKeycloak que tenta `await keycloak.init({ onLoad: 'login-required', checkLoginIframe: true, pkceMethod: 'S256' })` catching errors e sempre setando isLoading=false no finally, se authenticated=true chama loadUserProfile async que executa `const profile = await keycloak.loadUserProfile()` e `const token = keycloak.tokenParsed` construindo user object { id: token.sub, username: profile.username, email: profile.email, name: profile.firstName + ' ' + profile.lastName, tenantId: token.tenant_id, allowedTenants: token.allowed_tenants, roles: token.realm_access?.roles || [] } setando setUser(user), depois chama setupTokenRefresh(), setupTokenRefresh function seta setInterval de 240000ms executando `keycloak.updateToken(60).then(refreshed => { if (refreshed) loadUserProfile() }).catch(() => logout())`.

Methods object value contém isAuthenticated, isLoading, user, login implementado como `() => keycloak.login()`, logout implementado como `() => keycloak.logout({ redirectUri: window.location.origin })`, switchTenant implementado como `async (tenantId) => { if (!user?.allowedTenants.includes(tenantId)) throw Error('Tenant not allowed'); const token = await getToken(); await fetch(API_URL + '/api/auth/switch-tenant', { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': Bearer ${token} }, body: JSON.stringify({ tenantId }) }); await keycloak.updateToken(-1); await loadUserProfile(); window.location.reload(); }`, hasRole implementado como `(roles) => roles.some(role => user?.roles.includes(role))`, getToken implementado como `async () => { await keycloak.updateToken(30); return keycloak.token }`, retorna `<AuthContext.Provider value={value}>{isLoading ? <LoadingScreen /> : children}</AuthContext.Provider>`.

UseAuth hook exportado como `export function useAuth() { const context = useContext(AuthContext); if (!context) throw Error('useAuth must be used within AuthProvider'); return context; }`, usado em components como `const { user, isAuthenticated, login, logout, hasRole, getToken } = useAuth()`, PrivateRoute component usa useAuth para proteger rotas implementado como `function PrivateRoute({ children, roles }) { const { isAuthenticated, hasRole } = useAuth(); if (!isAuthenticated) return <Navigate to="/login" replace />; if (roles && !hasRole(roles)) return <Navigate to="/forbidden" replace />; return <>{children}</>; }`, TenantSwitcher component usa useAuth para dropdown implementado como `function TenantSwitcher() { const { user, switchTenant } = useAuth(); if (!user || user.allowedTenants.length <= 1) return null; return <select value={user.tenantId} onChange={(e) => switchTenant(e.target.value)}>{user.allowedTenants.map(t => <option key={t} value={t}>{t}</option>)}</select>; }`.
