GEOWEB segue Feature-Sliced Design (FSD) com layers hierárquicas onde app layer contém configuração top-level incluindo src/app/App.tsx root component, src/app/providers/ com QueryClientProvider, AuthProvider, ThemeProvider, src/app/router/ com BrowserRouter e Routes definition, src/app/styles/ com global.css Tailwind imports, features layer contém módulos de negócio isolados como src/features/auth/ com components/ (LoginForm, LogoutButton, TenantSwitcher), api/ (switchTenant.ts, getUserProfile.ts), hooks/ (useAuth.ts), types/ (User.ts, AuthState.ts), src/features/units/ com components/ (UnitsList, UnitForm, UnitDetails), api/ (getUnits.ts, createUnit.ts, updateUnit.ts, deleteUnit.ts), hooks/ (useUnits.ts, useCreateUnit.ts), types/ (Unit.ts, CreateUnitDto.ts), cada feature não importa de outras features garantindo isolamento, entities layer contém modelos de domínio reutilizáveis como src/entities/user/ com model/ (User.ts interface), ui/ (UserCard.tsx component genérico), lib/ (formatUserName.ts helper), src/entities/unit/ similarmente, entities podem ser importadas por features mas não importam features, shared layer contém código genérico reutilizável como src/shared/ui/ com componentes Button.tsx, Input.tsx, Modal.tsx, Select.tsx sem lógica de negócio, src/shared/lib/ com utils formatDate.ts, validateCPF.ts, constants.ts, src/shared/api/ com axios instance base configuration, shared pode ser importado por todos os layers superiores, dependências fluem apenas para baixo seguindo regra app → features → entities → shared, features não podem importar outras features prevenindo coupling, se código precisa ser compartilhado entre features deve ser movido para entities ou shared layer, AuthContext especial porque auth cross-cutting concern então fica em shared/lib/auth/ exportando useAuth hook disponível para todas features, routing structure em app/router/ define `<Route path="/units" element={<PrivateRoute roles={['field-collector']}><UnitsPage /></PrivateRoute>} />` onde UnitsPage component importa de features/units/pages/UnitsPage.tsx, UnitsPage usa useUnits() hook que faz TanStack Query useQuery chamando getUnits() da api layer que usa axios instance com Authorization header automaticamente, data retornada renderizada via UnitsList component com mapping units.map(unit => <UnitCard key={unit.id} unit={unit} />), mutation hooks como useCreateUnit retorna useMutation com mutationFn: createUnit, onSuccess: () => queryClient.invalidateQueries(['units']), optimistic updates via onMutate: async (newUnit) => { await queryClient.cancelQueries(['units']); const previousUnits = queryClient.getQueryData(['units']); queryClient.setQueryData(['units'], old => [...old, newUnit]); return { previousUnits } }, onError: (err, variables, context) => { queryClient.setQueryData(['units'], context.previousUnits) }, state management distribuído com TanStack Query para server state, Zustand para UI state como `const useSidebarStore = create((set) => ({ isOpen: false, toggle: () => set(state => ({ isOpen: !state.isOpen })) }))`, React Context apenas para auth porque precisa estar disponível globalmente sem prop drilling.
