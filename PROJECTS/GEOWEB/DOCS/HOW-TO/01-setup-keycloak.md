Setup Keycloak no GEOWEB requer primeiro instalar keycloak-js com `npm install keycloak-js`, criar .env.local com VITE_KEYCLOAK_URL=http://localhost:8080, VITE_KEYCLOAK_REALM=carf, VITE_KEYCLOAK_CLIENT_ID=geoweb, VITE_API_URL=http://localhost:5000, criar src/lib/keycloak.ts exportando `const keycloak = new Keycloak({ url: import.meta.env.VITE_KEYCLOAK_URL, realm: import.meta.env.VITE_KEYCLOAK_REALM, clientId: import.meta.env.VITE_KEYCLOAK_CLIENT_ID })` e `export default keycloak`, criar src/contexts/AuthContext.tsx com AuthProvider component que em useEffect chama initKeycloak() async function executando `await keycloak.init({ onLoad: 'login-required', checkLoginIframe: true, pkceMethod: 'S256' })` que redireciona para login se não autenticado, se authenticated chama loadUserProfile() que executa `const profile = await keycloak.loadUserProfile()` e `const token = keycloak.tokenParsed` construindo user object com id: token.sub, username: profile.username, email: profile.email, name: firstName + lastName, tenantId: token.tenant_id, allowedTenants: token.allowed_tenants array, roles: token.realm_access.roles array, seta isAuthenticated=true, chama setupTokenRefresh() que configura setInterval de 240000ms executando `keycloak.updateToken(60).then(refreshed => { if (refreshed) loadUserProfile() }).catch(() => logout())` para refresh automático, AuthContext.Provider value exporta { isAuthenticated, user, login: () => keycloak.login(), logout: () => keycloak.logout({ redirectUri: window.location.origin }), switchTenant, hasRole, getToken: async () => { await keycloak.updateToken(30); return keycloak.token } }, exporta useAuth() hook que retorna useContext(AuthContext) com validação throw Error se usado fora de provider, em src/main.tsx importa AuthProvider e wrapa <App /> com <AuthProvider><App /></AuthProvider>, criar src/components/PrivateRoute.tsx que recebe { children, roles } props, usa useAuth(), retorna <Navigate to="/login" /> se não autenticado, <Navigate to="/forbidden" /> se roles definido e hasRole(roles) false, <>{children}</> caso contrário, em src/Router.tsx usar PrivateRoute como `<Route path="/occupations" element={<PrivateRoute roles={['field-collector', 'analyst', 'admin']}><Occupations /></PrivateRoute>} />`, criar src/lib/api.ts com axios instance baseURL do .env, interceptor request `config.headers.Authorization = Bearer ${await getToken()}` importando getToken do useAuth, interceptor response detectando 401 e chamando keycloak.login(), criar useApi() hook retornando { fetchApi } wrapper que usa axios instance, testar iniciando Keycloak local com docker-compose up -d, acessando Admin Console http://localhost:8080 admin/admin, verificando realm carf importado, verificando client geoweb configurado com Valid Redirect URIs incluindo http://localhost:5173/*, Web Origins +, Standard Flow Enabled ON, PKCE Code Challenge Method S256, criando user teste com username, email, password temporary OFF, attributes tenants=[\"prefeitura-teste\"], current_tenant=[\"prefeitura-teste\"], role mappings analyst, iniciando GEOWEB com npm run dev, acessando http://localhost:5173, sendo redirecionado para Keycloak login, fazendo login com user teste, sendo redirecionado de volta para app com authorization code na URL, verificando que keycloak-js automatically exchanged code por tokens, verificando no React DevTools que AuthContext.user contém dados corretos incluindo tenantId e roles, verificando no Network tab que requests ao backend incluem Authorization header com Bearer token, verificando que dados retornados do backend são filtrados por tenant correto via RLS PostgreSQL.
