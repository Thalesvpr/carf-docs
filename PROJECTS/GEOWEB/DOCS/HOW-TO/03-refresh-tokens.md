Token refresh no GEOWEB implementado via setupTokenRefresh() function em AuthContext que configura setInterval com delay de 240000ms (4 minutos) executando `keycloak.updateToken(60).then(refreshed => { if (refreshed) { console.log('Token refreshed'); loadUserProfile(); } }).catch(() => { console.error('Failed to refresh token'); keycloak.login(); })` onde keycloak.updateToken(60) checa se access token expira em menos de 60 segundos comparando exp claim do tokenParsed com timestamp atual, se token ainda válido por mais de 60s retorna Promise.resolve(false) sem fazer nada, se token expira em menos de 60s ou já expirou faz POST ao http://localhost:8080/realms/carf/protocol/openid-connect/token com body form-urlencoded grant_type=refresh_token, client_id=geoweb, refresh_token (keycloak.refreshToken atual).

Keycloak valida refresh_token checando que pertence ao client correto e sessão SSO ainda válida, retorna novo access_token com exp renovado (+5 minutos), opcionalmente novo refresh_token se sessão SSO foi renovada, keycloak-js atualiza keycloak.token, keycloak.tokenParsed, keycloak.refreshToken se fornecido novo, retorna Promise.resolve(true) indicando que refresh ocorreu, then callback checa if (refreshed) e se true chama loadUserProfile() para atualizar user state porque tenant_id claim pode ter mudado se user fez switch tenant em outra tab/window, catch callback executa se refresh falha porque sessão SSO expirou (idle timeout 30min ou max timeout 10h) ou refresh_token foi revogado manualmente, então chama keycloak.login() redirecionando para login screen.

Interval de 4 minutos escolhido porque access token dura 5 minutos então refresh acontece 1 minuto antes de expirar prevenindo janela de requests falhando com 401 entre token expirar e refresh completar, updateToken(60) com parâmetro 60 segundos significa refresh se expira em menos de 1 minuto então mesmo que setInterval delay pequeno apenas refresha quando necessário evitando calls desnecessários, edge case de user fecha tab antes de refresh interval executar não é problema porque ao re-abrir app keycloak.init() checa se sessão SSO válida via checkLoginIframe=true que usa iframe hidden fazendo silent authentication sem redirect, se sessão válida obtém novo access token automaticamente, se sessão expirou redireciona para login.

Manual refresh forçado possível chamando await keycloak.updateToken(-1) com -1 forçando refresh imediato mesmo que token não esteja próximo de expirar útil após tenant switch para obter novo tenant_id claim ou após backend atualizar user roles para refletir mudanças imediatamente sem esperar interval.
