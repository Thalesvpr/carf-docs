GEOWEB integra Keycloak como public client usando keycloak-js library (versão 24.0.0+) que implementa OAuth2 Authorization Code + PKCE flow automaticamente, iniciando com `const keycloak = new Keycloak({ url, realm, clientId })` seguido por `await keycloak.init({ onLoad: 'login-required', checkLoginIframe: true, pkceMethod: 'S256' })` que redireciona usuário para Keycloak login screen se não autenticado, gera code_verifier e code_challenge automaticamente, recebe authorization code via redirect callback, exchang

e code por tokens incluindo code_verifier para PKCE validation, armazena access_token, id_token e refresh_token em memória (não localStorage), popula keycloak.token, keycloak.tokenParsed, keycloak.authenticated boolean, AuthContext wrapper React context provê interface limpa com `const { user, isAuthenticated, login, logout, switchTenant, hasRole, getToken } = useAuth()` onde user object é construído parseando keycloak.tokenParsed extraindo claims sub, preferred_username, email, name, tenant_id, allowed_tenants, realm_access.roles, setupTokenRefresh() configura setInterval de 4 minutos chamando keycloak.updateToken(60) que checa se token expira em menos de 60 segundos e se sim faz POST ao token endpoint com grant_type=refresh_token obtendo novo access_token atualizando keycloak.token e recarregando user profile com novo tenant_id caso tenha mudado, se refresh falha redireciona para login via keycloak.login(), TenantSwitcher component renderiza dropdown apenas se user.allowedTenants.length > 1, ao onChange chama switchTenant(tenantId) que valida se tenantId está em allowedTenants, POST /api/auth/switch-tenant no backend que atualiza current_tenant attribute no Keycloak user, força keycloak.updateToken(-1) para refresh imediato, recarrega user profile, faz window.location.reload() para limpar TanStack Query cache garantindo que dados são re-fetched do novo tenant, API client Axios configurado com interceptor request que adiciona `config.headers.Authorization = Bearer ${await keycloak.token}` chamando keycloak.updateToken(5) antes para garantir token válido, interceptor response que se status 401 e erro "Token is not active" chama keycloak.login() redirecionando para re-autenticação, role-based UI rendering usa hasRole(['analyst', 'admin']) retornando boolean baseado em keycloak.hasRealmRole() checando realm_access.roles claim do token parsed, PrivateRoute component wrapper que recebe roles optional prop, checa isAuthenticated e se false retorna <Navigate to="/login" />, se roles definido checa hasRole(roles) e se false retorna <Navigate to="/forbidden" />, caso contrário renderiza children permitindo acesso, e logout executa keycloak.logout({ redirectUri: window.location.origin }) que faz GET ao logout endpoint do Keycloak invalidando sessão SSO de todas as 6 aplicações simultaneamente e redirect de volta para origin após logout completo.

---

**Última atualização:** 2026-01-15
**Status do arquivo**: Incompleto
Descrição: Falta título H1 na primeira linha.
