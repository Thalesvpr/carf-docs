Multi-tenancy no ecossistema CARF implementado via user attributes no Keycloak onde cada usuário possui `tenants` (multi-valued array ["prefeitura-a", "prefeitura-b", "prefeitura-c"] representando municípios aos quais tem acesso) e `current_tenant` (single string "prefeitura-a" indicando tenant ativo no momento), mapeados para JWT access token via Protocol Mapper tipo "User Attribute" configurado em Client Scopes → profile → Mappers → Add mapper → User Attribute com User Attribute = current_tenant, Token Claim Name = tenant_id, Claim JSON Type = String, Add to access token = ON resultando em claim `"tenant_id":"prefeitura-a"` presente em todo access token emitido, permitindo tenant switcher no frontend implementado como dropdown React component exibindo tenants disponíveis do array allowed_tenants extraído do token decoded.

Ao trocar tenant usuário chama endpoint backend POST `/api/auth/switch-tenant` com body `{"tenantId":"prefeitura-b"}`, backend autentica request via JWT bearer validation extraindo user sub claim, chama Keycloak Admin API GET `/admin/realms/carf/users/{userId}` com admin access token para obter user completo, valida que novo tenantId está presente em user attributes tenants array retornando 403 Forbidden se não autorizado, atualiza user via PUT `/admin/realms/carf/users/{userId}` modificando apenas attributes.current_tenant para novo valor preservando demais atributos, retorna 200 OK ao frontend, frontend chama keycloak.updateToken(-1) forçando refresh imediato via refresh_token grant obtendo novo access token contendo tenant_id com novo valor.

Todas requisições subsequentes para backend automaticamente filtram dados pelo novo tenant_id devido a Row-Level Security PostgreSQL implementado via middleware ASP.NET Core executando antes de cada request extraindo tenant_id claim do JWT via User.FindFirst("tenant_id")?.Value, abrindo database connection e executando SQL `SET LOCAL app.tenant_id = '{tenant_id}'` antes de qualquer query, RLS policies criadas em cada tabela via `CREATE POLICY tenant_isolation ON units USING (tenant_id = current_setting('app.tenant_id')::uuid) WITH CHECK (tenant_id = current_setting('app.tenant_id')::uuid)` garantindo que SELECT retorna apenas rows do tenant ativo, INSERT/UPDATE/DELETE só podem afetar rows do tenant ativo, e tentativas de acessar dados de outros tenants resultam em rows vazias ou permission denied sem necessidade de WHERE tenant_id = ? em cada query manual pois PostgreSQL aplica filtro automaticamente e transparentemente, alternative implementation seria schema-per-tenant criando schema separado por município mas complexifica migrations e backups, ou database-per-tenant isolando completamente dados físicamente mas limitando escalabilidade horizontal e complicando cross-tenant reporting e analytics, RLS approach escolhido por balancear isolamento forte (tenant A nunca vê dados de tenant B mesmo com SQL injection ou bug em application code) com simplicidade operacional (single database, unified migrations, backups atômicos, cross-tenant queries possíveis via SET SESSION para super-admin dashboard agregando métricas de todos municípios).

Tenant_id propagado para todos microservices via JWT sem necessidade de shared state ou session store pois cada service independentemente valida JWT e extrai tenant_id, tenant onboarding executado via ADMIN app chamando Keycloak Admin API POST `/admin/realms/carf/users` criando novo user ou PATCH existente adicionando novo tenant no array tenants e definindo como current_tenant, tenant offboarding remove tenant do array via PATCH mas não deleta dados físicos pois DELETE CASCADE manual necessário para compliance com LGPD exigindo procedimento formal de deleção com auditoria e possível retenção temporária para período de appeal, e tenant-aware logging captura tenant_id em structured logs (Serilog, ELK) permitindo filtrar e correlacionar events por município facilitando debugging de issues reportados por prefeituras específicas sem poluir logs de outros tenants, garantindo multi-tenancy seguro, escalável e operacionalmente simples alinhado com requisitos de SaaS municipal onde cada prefeitura é tenant independente mas compartilha infraestrutura comum reduzindo custos e simplificando manutenção.

---

**Última atualização:** 2026-01-15
**Status do arquivo**: Incompleto
Descrição: Falta título H1 na primeira linha.
