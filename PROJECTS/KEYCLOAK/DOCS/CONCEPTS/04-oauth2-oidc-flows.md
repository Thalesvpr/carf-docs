OAuth2 e OpenID Connect no Keycloak implementam múltiplos flows sendo Authorization Code + PKCE usado por SPAs (geoweb React) e mobile apps (reurbcad React Native) onde frontend redireciona para `/realms/carf/protocol/openid-connect/auth?client_id=geoweb&redirect_uri=http://localhost:3000/callback&response_type=code&scope=openid profile email&code_challenge=BASE64URL(SHA256(code_verifier))&code_challenge_method=S256` gerando code_verifier aleatório 43-128 chars armazenado em sessionStorage, usuário autentica e consente, Keycloak redireciona de volta com authorization code na URL, frontend troca code por tokens via POST `/protocol/openid-connect/token` com grant_type=authorization_code, code, redirect_uri, client_id, code_verifier (sem client_secret pois public client), recebendo JSON com access_token JWT RS256 válido 5 minutos, refresh_token válido 30 minutos, id_token com user info, token_type Bearer, expires_in 300, scope "openid profile email", enquanto Client Credentials flow é usado por serviços M2M como geogis Python fazendo POST `/protocol/openid-connect/token` com grant_type=client_credentials, client_id=geogis, client_secret=<secret> via Basic Auth header ou form-encoded recebendo access token sem refresh token nem id_token pois não representa user mas sim aplicação, e Refresh Token flow mantém sessão viva executando POST `/protocol/openid-connect/token` com grant_type=refresh_token, refresh_token=<token>, client_id antes de access token expirar obtendo novos access/refresh/id tokens com mesmos claims e sessão renovada até idle timeout ou absolute timeout atingidos.

JWT access token estruturado como header `{"alg":"RS256","typ":"JWT","kid":"<key-id>"}` indicando algoritmo RSA SHA-256 e key ID para localizar chave pública em `/protocol/openid-connect/certs` JWKS endpoint, payload `{"sub":"user-uuid","iss":"http://keycloak:8080/realms/carf","exp":1704820800,"iat":1704820500,"tenant_id":"prefeitura-a","allowed_tenants":["prefeitura-a","prefeitura-b"],"realm_access":{"roles":["analyst","user"]},"resource_access":{"geoapi":{"roles":["read","write"]}},"email":"joao@example.com","name":"João Silva","preferred_username":"joao.silva"}` contendo user ID sub, issuer iss para validação, expiration timestamp exp e issued at iat para lifetime check, custom claims tenant_id e allowed_tenants para multi-tenancy, roles em realm_access e per-client em resource_access, e user profile email/name/username, assinatura gerada com chave privada RSA do Keycloak e validável com chave pública exposta em JWKS endpoint garantindo integridade sem necessidade de chamar Keycloak para cada request (stateless validation), OIDC Discovery em `/.well-known/openid-configuration` retornando JSON com todos endpoints (authorization_endpoint, token_endpoint, userinfo_endpoint, jwks_uri, end_session_endpoint), supported grant_types, response_types, scopes, claims, e algorithms permitindo configuração automática de OIDC clients lendo metadata.

UserInfo endpoint `/protocol/openid-connect/userinfo` com Authorization Bearer header retornando claims do usuário em JSON usado para obter informações atualizadas do perfil sem decode JWT, Introspect endpoint `/protocol/openid-connect/token/introspect` com POST form-encoded token=<access_token>, client_id, client_secret retornando JSON `{"active":true,"sub":"user-uuid","tenant_id":"prefeitura-a",...}` para validação server-side quando backend prefere call Keycloak a validar assinatura localmente (tradeoff latência vs load no Keycloak), Revoke endpoint `/protocol/openid-connect/revoke` com POST token=<refresh_token> invalidando refresh token e consequentemente access tokens dessa sessão forçando re-authentication, End Session (logout) via GET/POST `/protocol/openid-connect/logout?id_token_hint=<id_token>&post_logout_redirect_uri=http://localhost:3000` terminando sessão SSO e invalidando todos tokens da sessão em todos clients (geoweb, reurbcad, admin) simultaneamente com redirect de volta para aplicação, Backchannel Logout via HTTP POST para registered backchannel_logout_uri de cada client com logout_token JWT permitindo backends serem notificados de logout e invalidarem sessões locais (ex: Redis cache).

Token Exchange permitindo trocar token de um client por token de outro client via POST grant_type=urn:ietf:params:oauth:grant-type:token-exchange, subject_token=<access_token>, requested_token_type=urn:ietf:params:oauth:token-type:access_token, audience=outro-client-id facilitando comunicação inter-services preservando contexto do user original, e Device Authorization Grant para dispositivos com input limitado (smart TV, IoT) onde device faz POST `/oauth/device_authorization` recebendo device_code e user_code, mostra user_code para usuário digitar em `/device` no browser em outro device, device pollea `/protocol/openid-connect/token` com grant_type=urn:ietf:params:oauth:grant-type:device_code até usuário autorizar, todos flows seguindo RFC 6749 (OAuth 2.0), RFC 7636 (PKCE), RFC 8252 (OAuth for Native Apps), OpenID Connect Core 1.0, garantindo interoperabilidade com bibliotecas padrão keycloak-js (JavaScript), react-native-app-auth (React Native), oidc-client-ts (TypeScript), python-keycloak (Python), Microsoft.AspNetCore.Authentication.JwtBearer (.NET).

---

**Última atualização:** 2026-01-15
**Status do arquivo**: Incompleto
Descrição: Falta título H1 na primeira linha.
