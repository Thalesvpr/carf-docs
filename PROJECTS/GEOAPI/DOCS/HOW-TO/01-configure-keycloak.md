Configurar Keycloak authentication no GEOAPI requer primeiro adicionar pacote NuGet Microsoft.AspNetCore.Authentication.JwtBearer via `dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer`, depois criar seção Keycloak em appsettings.json com Authority apontando para `http://localhost:8080/realms/carf` em dev ou `https://auth.carf.example.com/realms/carf` em prod, Audience=geoapi, RequireHttpsMetadata=false em dev ou true em prod, ValidateAudience=true, ValidateIssuer=true, ValidateLifetime=true, ClockSkew=00:00:00 (zero tolerância), em Program.cs adicionar `builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).AddJwtBearer(options => { })` configurando options.Authority do appsettings, options.Audience do appsettings, options.RequireHttpsMetadata do appsettings, options.TokenValidationParameters com ValidateIssuer=true, ValidateAudience=true, ValidateLifetime=true, ValidateIssuerSigningKey=true, ClockSkew=TimeSpan.Zero, RoleClaimType="realm_access.roles" para mapear roles corretamente, NameClaimType="preferred_username", options.Events com OnTokenValidated para logar validações bem-sucedidas, OnAuthenticationFailed para logar erros, adicionar `builder.Services.AddAuthorization()`, em middleware pipeline usar ordem correta com app.UseAuthentication() antes de app.UseAuthorization() antes de app.UseTenantMiddleware() antes de app.MapControllers(), criar TenantMiddleware.cs que recebe RequestDelegate e ILogger no constructor, implementa InvokeAsync recebendo HttpContext e AppDbContext injetado, verifica se User.Identity.IsAuthenticated, extrai tenantId de User.FindFirst("tenant_id")?.Value, executa `await db.Database.ExecuteSqlRawAsync("SET LOCAL app.tenant_id = {0}", tenantId)` com parameter binding para prevenir SQL injection, loga tenantId sendo setado, chama await _next(context), registrar middleware com extension method UseTenantMiddleware() que chama UseMiddleware<TenantMiddleware>(), configurar CORS com builder.Services.AddCors adicionando policy que permite origins dos frontends (http://localhost:5173 dev, https://geoweb.carf.example.com prod), AllowAnyMethod(), AllowAnyHeader(), AllowCredentials(), usar app.UseCors() antes de authentication, testar localmente iniciando Keycloak com docker-compose, acessando http://localhost:8080 com admin/admin, criando user de teste em realm carf com username, email, password (temporary OFF), attributes tenants=["prefeitura-teste"], current_tenant=["prefeitura-teste"], role mappings analyst, obtendo token via `curl -X POST http://localhost:8080/realms/carf/protocol/openid-connect/token -d client_id=geoapi -d grant_type=password -d username=teste -d password=senha123 | jq -r .access_token`, fazendo request ao GEOAPI com `curl -H "Authorization: Bearer $TOKEN" http://localhost:5000/api/occupations` e verificando que retorna dados filtrados por tenant.
