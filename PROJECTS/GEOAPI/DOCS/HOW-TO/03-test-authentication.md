Testar authentication no GEOAPI integration tests requer primeiro escolher estratégia entre usar Testcontainers para Keycloak real (mais realista mas mais lento) ou mock tokens (mais rápido mas menos confiável), para Testcontainers strategy instalar pacote `dotnet add package Testcontainers.Keycloak`, criar KeycloakContainer em test fixture com `new KeycloakBuilder().WithImage("quay.io/keycloak/keycloak:24.0.0").WithUsername("admin").WithPassword("admin").WithRealmImportFile("realm-export.json").Build()`, start container no SetUp com `await _keycloakContainer.StartAsync()`, obter auth server URL com `_keycloakContainer.GetAuthServerUrl()`, configurar WebApplicationFactory para usar Keycloak test URL override em appsettings, criar user de teste via Keycloak Admin API usando KcAdminClient com `await kcAdmin.auth()`, `await kcAdmin.users.create({ username, email, credentials: [{ type: "password", value: "test123", temporary: false }], attributes: { tenants: ["test-tenant"], current_tenant: ["test-tenant"] } })`, atribuir role analyst via `await kcAdmin.users.addRealmRoleMappings({ id: userId, roles: [{ id: roleId, name: "analyst" }] })`, obter access token via password grant usando HttpClient POST ao token endpoint com form data client_id=geoapi, grant_type=password, username=test, password=test123, parsear response JSON extraindo access_token, usar token em test requests configurando HttpClient com `client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", token)`, fazer request ao endpoint protegido como `await client.GetAsync("/api/occupations")`, assert response status code 200 OK e que dados retornados pertencem ao test-tenant verificando tenantId nos objetos, fazer request sem token e assert 401 Unauthorized, fazer request com token expirado gerando token mock com exp no passado e assert 401 com error message "Token is not active", fazer request com role insuficiente criando user com role field-collector tentando acessar endpoint que requer analyst e assert 403 Forbidden, stop container no TearDown com `await _keycloakContainer.StopAsync()`, para mock tokens strategy criar helper method GenerateJwtToken que recebe claims dictionary e retorna token string, usar SymmetricSecurityKey com secret compartilhada configurada no backend via AddJwtBearer options.TokenValidationParameters.IssuerSigningKey, criar JwtSecurityToken com issuer=http://test, audience=geoapi, claims convertidos para Claim objects, expires=DateTime.UtcNow.AddMinutes(5), signingCredentials com HmacSha256, escrever token com new JwtSecurityTokenHandler().WriteToken(), configurar backend para aceitar mock issuer adicionando ValidIssuers array em TokenValidationParameters, gerar token com claims tenant_id=test-tenant, sub=test-user, realm_access.roles=["analyst"], usar em test requests da mesma forma, vantagem é velocidade porque não precisa Docker overhead mas desvantagem é não testar integração real com Keycloak então pode perder bugs relacionados a token format, claims mapping, ou RLS configuration, recomendação é usar Testcontainers para smoke tests críticos e mock tokens para unit tests rápidos de authorization logic, e sempre testar localmente com Keycloak real via `docker-compose up -d` antes de push para garantir que integration funciona end-to-end.
