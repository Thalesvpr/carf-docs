Authentication no GEOAPI usa OAuth2 OIDC com Keycloak onde frontend GEOWEB REURBCAD faz Authorization Code + PKCE flow obtendo access token JWT assinado com RS256 contendo claims sub user id iss issuer keycloak realm exp expiration timestamp iat issued at tenant_id tenant atual allowed_tenants array realm_access.roles array de roles email e name que é enviado em todas as requisições HTTP no header Authorization: Bearer <token> recebido por middleware JWT Bearer que baixa chaves públicas do endpoint .well-known/openid-configuration do Keycloak para validar assinatura do token verificando que foi emitido pelo Keycloak correto e não foi alterado.

Middleware valida issuer checando que vem do realm carf valida audience verificando que token foi emitido para este backend geoapi valida lifetime checando que token não expirou comparando exp claim com timestamp atual sem tolerância ClockSkew=Zero popula HttpContext.User com ClaimsPrincipal contendo todos os claims do token permitindo acesso via User.FindFirst("claim_name") em controllers e middleware e em caso de falha retorna 401 Unauthorized com WWW-Authenticate header informando erro token inválido expirado ou malformado.

Token refresh é responsabilidade do frontend que usa refresh_token para obter novo access token antes de expirar 5 minutos via endpoint /protocol/openid-connect/token com grant_type=refresh_token e logout invalida sessão SSO no Keycloak via endpoint /protocol/openid-connect/logout com id_token_hint e post_logout_redirect_uri fazendo logout de todas as 6 aplicações simultaneamente mantendo Single Sign-Out consistente prevenindo sessões órfãs ativas outros clients após logout principal.
