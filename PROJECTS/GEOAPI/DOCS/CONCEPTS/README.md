Conceitos fundamentais do GEOAPI incluindo Clean Architecture com separação de responsabilidades em layers onde dependências apontam apenas para dentro (Domain não depende de nada, Application depende de Domain, Infrastructure depende de Application e Domain, Gateway depende de todos), CQRS com MediatR separando commands (write operations que retornam void ou entity ID) de queries (read operations que retornam DTOs otimizados) para permitir otimizações independentes e scaling horizontal, DDD com entities (identidade própria), value objects (imutáveis comparados por valor), aggregates (consistência transacional), domain events (comunicação entre bounded contexts) e repositories (abstração de persistência), Multi-tenancy via user attributes no Keycloak onde cada usuário tem `tenants: []` (array de tenants autorizados) e `current_tenant` (tenant ativo) mapeados para JWT claims que são usados por RLS PostgreSQL para filtrar dados automaticamente, OAuth2/OIDC authentication onde frontend obtém access token via PKCE flow e envia em requests como `Authorization: Bearer <token>` que backend valida e extrai claims, e Authorization via roles Keycloak (field-collector, analyst, admin, super-admin) com hierarquia composite onde admin inclui analyst e field-collector, super-admin inclui todos, validadas via [Authorize(Roles = "role1,role2")] em controllers ou verificadas programaticamente com HasAnyRole() para lógica condicional dentro de handlers.
