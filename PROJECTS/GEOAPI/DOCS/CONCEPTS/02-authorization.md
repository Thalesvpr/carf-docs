Authorization no GEOAPI implementa role-based access control (RBAC) com 4 realm roles Keycloak (field-collector, analyst, admin, super-admin) organizadas em hierarquia composite onde super-admin inclui todas as roles, admin inclui analyst e field-collector, analyst inclui field-collector, field-collector é base, cada role tem permissões específicas onde field-collector pode criar e editar próprias ocupações, analyst pode validar ocupações e criar processos além de tudo que field-collector faz, admin pode gerenciar usuários do próprio tenant e excluir ocupações além de tudo que analyst faz, super-admin pode criar tenants, transferir usuários entre tenants e acessar todos os tenants além de tudo que admin faz, validação de roles acontece em 3 níveis sendo primeiro nível [Authorize] attribute em controllers que bloqueia acesso se usuário não autenticado retornando 401 Unauthorized, segundo nível [Authorize(Roles = "analyst,admin,super-admin")] que permite acesso apenas para roles especificadas retornando 403 Forbidden se usuário tem role insuficiente, terceiro nível validação programática dentro de handlers usando HasAnyRole(["admin", "super-admin"]) para lógica condicional como admin só pode gerenciar usuários do próprio tenant enquanto super-admin pode gerenciar todos, RLS integration funciona em paralelo onde além de roles o tenant_id claim é extraído e usado para setar `app.tenant_id` no PostgreSQL garantindo que queries só retornam dados do tenant correto mesmo que usuário tenha role admin, prevenindo acesso acidental a dados de outros tenants, e composite roles no Keycloak evitam duplicação onde ao atribuir role admin ao usuário ele automaticamente ganha analyst e field-collector, facilitando gestão de permissões e garantindo consistência.
