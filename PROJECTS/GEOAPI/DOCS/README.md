# GEOAPI - Backend REST API .NET

API REST backend .NET 9 do sistema CARF fornecendo endpoints HTTP JSON para operações CRUD de unidades habitacionais comunidades titulares processos legitimação fundiária relatórios geoespaciais implementando Clean Architecture DDD Domain-Driven Design com separação rigorosa camadas Domain contendo entities aggregates value objects domain events regras negócio invariantes validações core business logic, Application orquestrando use cases via commands queries CQRS Command Query Responsibility Segregation handlers MediatR pipelines behaviors cross-cutting concerns logging validation authorization, Infrastructure provendo implementações concretas repositories Entity Framework Core mapeando aggregates tabelas PostgreSQL PostGIS integração serviços externos Keycloak OAuth2 SendGrid SMTP filestorage S3 message brokers RabbitMQ future implementations, e Presentation expondo APIs REST ASP.NET Core minimal APIs controllers endpoints HTTP recebendo requests JSON serializando responses DTOs Data Transfer Objects validando inputs autenticando autorizando via middleware pipelines. Arquitetura hexagonal ports adapters permite trocar infraestrutura database PostgreSQL para SQL Server MySQL, authentication Keycloak para Auth0 Azure AD B2C, storage local filesystem para S3 Azure Blob sem alterar domain business logic mantendo core isolado protegido mudanças tecnológicas frameworks libraries dependencies externas evitando vendor lock-in facilitando testes unitários mocking infrastructure dependencies injetando fakes stubs test doubles validando business rules isoladamente.

Backend conecta banco geoespacial PostgreSQL 16 PostGIS 3.4 armazenando geometrias Polygon MultiPolygon Point LineString colunas geography geometry indexadas GIST spatial indexes acelerando queries espaciais ST_Contains ST_Intersects ST_Distance ST_Area validações topológicas ST_IsValid garantindo geometrias válidas sem self-intersections holes inválidos degeneracies coordenadas corrompidas, Entity Framework Core mapeia aggregates raiz tabelas relacionadas via navigation properties configurando relacionamentos one-to-many many-to-many cascade deletes owned entities value objects convertidos via value converters serializando JSON arrays strings preservando encapsulamento domain model evitando anemic models expostos diretamente controllers. Multi-tenancy implementado Row-Level Security RLS PostgreSQL configurando policies CREATE POLICY units_tenant_isolation ON units USING tenant_id igual app.tenant_id session variable setada middleware ASP.NET Core extraindo claim JWT token SET LOCAL app.tenant_id ativando isolamento automático todas queries SELECT UPDATE DELETE filtrando tenant_id sem código repetido repositories services controllers garantindo zero chance cross-tenant data leakage bugs esquecimento filter manual desenvolvedor adicionando WHERE tenant_id cláusula esquecendo algum endpoint crítico expondo dados outros municípios violando LGPD soberania municipal compliance regulatório auditoria TCU Tribunal Contas União fiscalização sistemas públicos governo transparência dados abertos mas privacidade cidadãos protegida.

Autenticação validação tokens JWT Keycloak middleware ASP.NET Core JWT Bearer authentication verificando assinatura digital algoritmo RS256 chaves públicas obtidas JWKS endpoint Keycloak cached localmente atualizadas periodicamente detectando rotação keys automaticamente, extração claims user_id username email roles array tenant_id string allowed_tenants array propagados ClaimsPrincipal acessível controllers services via HttpContext User property injetado dependency injection, autorização implementada policies RequireRole super-admin admin manager analyst field-collector RequireTenant validando tenant_id claim matching resource acessado impedindo usuário tenant A acessar recursos tenant B mesmo autenticado válido RequirePermission granular validando ações específicas create read update delete por resource type units holders communities teams legitimation processes. Admin endpoints /api/admin/* gerenciam usuários tenants via Keycloak Admin REST API consumido backend usando confidential client com client_secret armazenado secure configuration Azure Key Vault AWS Secrets Manager HashiCorp Vault nunca commitado Git hardcoded código environment variables .env files gitignored protegendo credenciais sensíveis, frontend ADMIN console React chama endpoints GEOAPI que funcionam proxy intermediário adicionando sete camadas segurança validação rate limiting logging auditoria compliance antes repassar requests Keycloak Admin API evitando expor client_secret frontend JavaScript bundle inspecionável browser DevTools network tab permitindo usuário mal-intencionado extrair secret fazer requisições diretas Keycloak bypass validações GEOAPI comprometendo sistema inteiro criando super-admins deletando tenants corrompendo dados.

Features principais incluem CRUD geoespacial endpoints REST criar ler atualizar deletar unidades habitacionais geometrias validadas PostGIS cálculo automático área m² ST_Area queries espaciais buscar unidades dentro polígono comunidade bbox arbitrário filtros combinados espacial alfanumérico WHERE status aprovado AND ST_Contains community_polygon unit_polygon importação exportação GeoJSON Shapefile conversão formatos preservando projeções SRID 4326 WGS84 lat long 31983 SIRGAS2000 UTM zona 23S usado municípios São Paulo reprojetando automaticamente ST_Transform, multi-tenancy RLS isolamento automático dados session variables policies filtrando queries validação tenant_id comandos criação auditoria rastreando AccountId TenantId timestamps created_at updated_at deleted_at soft deletes mantendo histórico compliance LGPD direito esquecimento anonimização dados pessoais CPF nome endereço mantendo estatísticas agregadas analytics business intelligence relatórios gerenciais sem identificar indivíduos específicos, background processing jobs assíncronos Hangfire dashboard web monitorando execuções retry automático falhas scheduling cron expressions processando geração relatórios PDF Excel milhares unidades timeout 30 segundos requests HTTP inadequado operações longas 5 10 minutos renderização mapas charts tabelas formatação conteúdo importação shapefiles grandes 50MB 100MB splitting batches 500 features evitando memory overflow OutOfMemoryException crashes worker processes sincronização dados offline mobile detectando conflitos timestamps last-write-wins merge manual notificações email SendGrid templates dinâmicos substituting variables nome usuário município unidade aprovada rejeitada deadline documentação próximo vencimento alertando gestores técnicos responsáveis acompanhamento processos REURB evitando perda prazos legais Lei 13465/2017, e APIs consumidores frontend GEOWEB React TypeScript client tipado garantindo type safety compile-time catching errors antes runtime production crashes bad user experience mobile REURBCAD offline-first sync batch upload plugin GEOGIS QGIS WFS WMS layers visualização edição desktop GIS professional analysts técnicos experientes QGIS ArcGIS preferindo ferramentas robustas spatial analysis geoprocessing topology validation console ADMIN gerenciamento usuários tenants configuration system-wide settings portal WEBDOCS exemplos código documentação interativa tutorials quick-start guides facilitando onboarding novos desenvolvedores integrando sistemas externos third-party municipais legados SOAP XML migrating gradually microservices REST JSON modern stack.

Documentação técnica organiza arquitetura ADRs decisões Clean Architecture camadas separação concerns justificativas trade-offs alternativas consideradas monolith vs microservices escolhendo monolith modular initial simplicity evolving microservices later when scalability demands require, conceitos fundamentais DDD aggregates bounded contexts ubiquitous language CQRS separação read write models Event Sourcing future implementation storing domain events append-only log reconstructing state replaying events audit trail complete history changes temporal queries state snapshots performance optimization, guias práticos setup local Docker Compose PostgreSQL PgAdmin Keycloak mock SMTP Hangfire dashboard migrations running EF Core Add-Migration Update-Database seed data testing xUnit integration tests Testcontainers spinning PostgreSQL containers isolated per test cleanup automatic troubleshooting common errors connection strings RLS policies debugging middleware breakpoints inspecting JWT claims validating business rules, e camadas código estrutura solution projects Domain.csproj Application.csproj Infrastructure.csproj Presentation.csproj dependencies direcionais Domain zero dependencies Application depende Domain Infrastructure depende Application Domain Presentation depende todos orquestrando DI container explicando cada layer responsibilities boundaries contracts interfaces abstractions implementations concretions facilitating testing mocking infrastructure swapping implementations A/B testing feature flags gradual rollouts canary deployments blue-green zero-downtime deployments Kubernetes rolling updates readiness liveness probes health checks /health endpoint Prometheus metrics /metrics scraping Grafana dashboards alerting PagerDuty oncall engineers incidents production outages SLA 99.9% uptime availability reliability resilience fault-tolerance circuit breakers retries exponential backoff jitter chaos engineering testing failures deliberately improving robustness real-world scenarios network partitions database unavailability third-party API timeouts degraded performance load spikes traffic surges Black Friday municipal deadlines end fiscal year rush cadastro massivo unidades prazo legal projeto REURB funding federal governo recursos liberados condicionados cumprimento metas entregas comprovação resultados.

---

**Última atualização:** 2026-01-11
