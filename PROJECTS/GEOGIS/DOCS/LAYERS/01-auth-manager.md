AuthManager layer implementado como singleton class em src/auth/auth_manager.py garantindo single instance shared globally via _instance = None class variable @classmethod def getInstance(cls) returning cls._instance if cls._instance else cls._instance = cls() __init__(self) initializing KeycloakOpenID instance self.keycloak_openid = KeycloakOpenID(server_url=KEYCLOAK_URL, client_id=CLIENT_ID, realm_name=REALM, client_secret_key=CLIENT_SECRET) initializing token properties self.access_token = None self.refresh_token = None self.expires_at = None self.user_info = None login_service_account() method implementa client credentials flow calling token = self.keycloak_openid.token(grant_type='client_credentials') catching keycloak.exceptions.KeycloakAuthenticationError se credentials invalid se success storing tokens via self._store_tokens(token) internal method que executa settings = QSettings('CARF', 'GEOGIS') settings.setValue('access_token', token['access_token']) settings.setValue('refresh_token', token.get('refresh_token')) encrypted storage seting self.access_token = token['access_token'] self.expires_at = datetime.now() + timedelta(seconds=token['expires_in']) retornando True se success Exception se failure.

login_user() method implementa authorization code + PKCE flow gerando code_verifier = secrets.token_urlsafe(64) calculando code_challenge = base64.urlsafe_b64encode(hashlib.sha256(code_verifier.encode()).digest()).decode().rstrip('=') construindo auth_url com all parameters opening browser webbrowser.open(auth_url) starting local HTTP server httpd = HTTPServer(('localhost', 8888), CallbackHandler) blocking httpd.handle_request() até callback received CallbackHandler class nested dentro method extending BaseHTTPRequestHandler com do_GET() extracting code from URL query params = parse_qs(urlparse(self.path).query) code = params['code'][0] storing globally accessible variable responding HTML success message após callback exchanging code via requests.post(token_endpoint, data={'grant_type': 'authorization_code', 'client_id': CLIENT_ID, 'code': code, 'code_verifier': code_verifier, 'redirect_uri': 'http://localhost:8888/callback'}) parsing JSON response calling self._store_tokens(response.json()) loading user info via self._load_user_info() calling self.user_info = self.keycloak_openid.userinfo(self.access_token) retornando True se success Exception se failure.

getAccessToken() method checa if self.expires_at and datetime.now() < self.expires_at - timedelta(minutes=1) retorna self.access_token cached porque ainda válido caso contrário if not self.refresh_token raise Exception('No refresh token available') tenta refresh token = self.keycloak_openid.refresh_token(self.refresh_token) POST ao token endpoint se success chama self._store_tokens(token) atualizando tokens e expires_at retorna novo access_token se failure catching exception chama self.logout() limpando tokens e raising exception forçando re-login logout() method revoga token self.keycloak_openid.logout(self.refresh_token) POST ao revoke endpoint limpa QSettings settings.remove('access_token') settings.remove('refresh_token') reseta properties self.access_token = None self.refresh_token = None self.expires_at = None.

restoreSession() method chamado plugin startup tenta settings = QSettings('CARF', 'GEOGIS') self.refresh_token = settings.value('refresh_token') se refresh_token exists tenta self.getAccessToken() que fará refresh validating session se success retorna True sem mostrar login dialog se failure ou token não exists retorna False forçando login manual usage em plugin code auth_manager = AuthManager.getInstance() if not auth_manager.restoreSession(): show_login_dialog() conditional authentication obtendo token para API calls token = auth_manager.getAccessToken() automatically handling refresh session lifecycle management complete desde initialization login refresh logout cleanup state transitions error recovery authentication failures network issues token expiration handling graceful degradation showing appropriate user feedback dialogs messages preventing crashes silent failures maintaining security posture throughout plugin usage lifecycle.

---

**Última atualização:** 2026-01-15
**Status do arquivo**: Incompleto
Descrição: Falta título H1 na primeira linha.
