API requests no GEOGIS implementadas via ApiClient class wrapper ao redor requests.Session() provendo interface limpa para fazer HTTP calls ao GEOAPI implementação em src/api/api_client.py com class ApiClient: def __init__(self, auth_manager) storing auth_manager reference creating self.session = requests.Session() com base_url configuration configuring retry strategy com retry = Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504]) e adapter = HTTPAdapter(max_retries=retry) então self.session.mount('http://', adapter) e self.session.mount('https://', adapter) _request(self, method, endpoint, **kwargs) internal method obtendo token com token = self.auth_manager.getAccessToken() que automatically refresh se necessário adicionando header self.session.headers.update Authorization Bearer token construindo full URL url = f'{self.base_url}{endpoint}' fazendo request response = self.session.request(method, url, timeout=30, **kwargs) com timeout preventing hangs.

Handling errors response.raise_for_status() raising HTTPError se status 4xx 5xx catching 401 Unauthorized except requests.exceptions.HTTPError as e: if e.response.status_code == 401 tentando refresh token uma vez self.auth_manager.getAccessToken(force_refresh=True) depois retry request se falha novamente raising error forçando re-authentication retornando return response.json() parsed JSON public methods get(self, endpoint, params=None) wrapper calling self._request('GET', endpoint, params=params) post(self, endpoint, json=None) calling self._request('POST', endpoint, json=json) put(self, endpoint, json=None) delete(self, endpoint) domain-specific methods get_occupations(self, filters=None) calling self.get('/api/occupations', params=filters) retornando list of occupations create_occupation(self, data) calling self.post('/api/occupations', json=data) get_layers() calling self.get('/api/layers') retornando available WFS WMS layers metadata.

Usage em plugin code api_client = ApiClient(auth_manager) occupations = api_client.get_occupations(filters={'status': 'pending'}) obtendo filtered data iterating for occ in occupations: print(occ['address']) processing results error handling try except catching requests.exceptions.ConnectionError se network down showing message "Unable to connect to server" catching requests.exceptions.Timeout se request exceeds 30s showing "Request timed out" catching requests.exceptions.HTTPError se status error showing status code e message logging errors QgsMessageLog.logMessage() para debugging messages panel.

WFS layer loading especial caso usando API metadata construindo WFS URI uri = f"url={API_URL}/wfs&typename=occupations&version=2.0.0&srsname=EPSG:4326&authcfg={auth_cfg_id}" onde auth_cfg_id é QGIS authentication config ID storing Keycloak token criando layer layer = QgsVectorLayer(uri, 'Occupations', 'WFS') checking if not layer.isValid() showing error adding to map QgsProject.instance().addMapLayer(layer) alternative embedding token directly em URI uri += f"&headers=Authorization: Bearer {token}" mas menos secure porque token visible em project file XML upload files multipart form-data usando files = {'file': open('shapefile.shp', 'rb')} e api_client.post('/api/upload', files=files) com requests automatically handling multipart encoding download files binary content response = api_client.session.get('/api/export/shapefile', stream=True) então with open('output.zip', 'wb') as f: for chunk in response.iter_content(chunk_size=8192): f.write(chunk) streaming para avoid loading entire file em memória efficient handling large exports batch processing.
