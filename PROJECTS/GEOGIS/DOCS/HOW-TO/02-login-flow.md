Login flow no GEOGIS implementado com LoginDialog PyQt5 dialog window mostrando dois radio buttons "Service Account" e "User Account", Service Account radio selected mostra label "Client ID" readonly field displaying configured client_id, label "Client Secret" masked QLineEdit para inserir secret, button "Login" enabled quando secret non-empty, User Account radio selected mostra label "Browser-based authentication" description text explaining flow, button "Login with Browser" enabled sempre, dialog code em src/ui/login_dialog.py extending QDialog with `def __init__(self, parent=None)` setting up UI, `def on_service_account_login(self)` handler checking client_secret field não empty, calling AuthManager.getInstance().login_service_account() em try/except block, showing QMessageBox.information() se sucesso com "Login successful!", closing dialog com self.accept(), showing QMessageBox.critical() se erro com exception message, `def on_user_account_login(self)` handler calling AuthManager.getInstance().login_user() que abre browser, starts local server, user completa login, código recebe callback, exchange tokens, retorna success/failure, showing appropriate message box, closing dialog se success, plugin main class implementa check_authentication() method em initGui() verificando `auth_manager = AuthManager.getInstance(); if not auth_manager.restore_session()` então `dialog = LoginDialog(self.iface.mainWindow()); result = dialog.exec_()` showing modal dialog blocking until user logs in ou cancels, se result == QDialog.Accepted significa login success então initializes plugin features loading layers, enabling toolbar actions, se result == QDialog.Rejected significa user cancelled então `QMessageBox.warning('Authentication required - Plugin will not function')`, não inicializa features deixando toolbar disabled, service account login flow detail AuthManager.login_service_account() valida client_secret exists, calls `token = self.keycloak_openid.token(grant_type='client_credentials')` fazendo POST ao token endpoint com client_id e client_secret no body, Keycloak valida credentials, retorna access_token sem user interaction, armazena token QSettings encrypted, seta expires_at timestamp, retorna True se success Exception se failure, user account login flow detail AuthManager.login_user() gera PKCE code_verifier e code_challenge, constrói auth_url com todos parameters, abre browser default com webbrowser.open() que navega para Keycloak, inicia http.server.HTTPServer em localhost:8888 blocking aguardando callback, user vê Keycloak login screen insere credentials, Keycloak valida credentials gera authorization code, redirect browser para http://localhost:8888/callback?code=abc123, local server recebe GET request extrai code, retorna HTML response "Login successful!", server shutdown após request, código exchange code por tokens POST ao token endpoint, armazena tokens QSettings, retorna True se success Exception se failure, auto-login on plugin startup implementa restore_session() tentando carregar refresh_token de QSettings, se exists tenta refresh para validar ainda válido, se refresh success seta authenticated=True não mostra login dialog, se refresh fails ou token não exists mostra LoginDialog forçando login manual, logout button no toolbar connected to logout_action triggered handler calling AuthManager.getInstance().logout() que revokes token, clears QSettings, shows message "Logged out successfully", disables plugin features até re-login.
