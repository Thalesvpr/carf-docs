GEOGIS integra Keycloak Python usando python-keycloak library instalada via `pip install python-keycloak` no QGIS Python environment, suporta dois authentication flows sendo Client Credentials Flow para service accounts executando `from keycloak import KeycloakOpenID; kc = KeycloakOpenID(server_url, realm_name, client_id, client_secret_key=secret); token = kc.token(grant_type='client_credentials')` retornando access_token sem user interaction ideal para scripts automatizados batch processing, e Authorization Code + PKCE Flow para user context abrindo browser system default com `import webbrowser; webbrowser.open(auth_url)` onde auth_url construída com client_id, redirect_uri=http://localhost:8888/callback, response_type=code, scope=openid profile email, code_challenge (SHA256 hash do code_verifier generated with secrets.token_urlsafe(64)), code_challenge_method=S256, local HTTP server via http.server.HTTPServer listening em porta 8888 recebe callback GET request com authorization code na URL query, extrai code com parse_qs(urlparse(request_path).query)['code'][0], exchange code por tokens fazendo POST ao token endpoint com requests.post() body incluindo grant_type=authorization_code, client_id, code, code_verifier (original unhashed), redirect_uri, response JSON parsed extraindo access_token, refresh_token, expires_in, AuthManager class armazena tokens em QSettings via QSettings('CARF', 'GEOGIS').setValue('access_token', token) que usa QGIS password manager encrypted storage platform-specific (Keychain macOS, KWallet Linux, Windows Credential Manager), getAccessToken() method checa if datetime.now() < self.expires_at - timedelta(minutes=1) retorna cached token caso contrário faz refresh com kc.refresh_token(refresh_token) POST ao token endpoint obtendo novo access_token atualizando QSettings e expires_at, se refresh falha (session expirou) chama logout() limpando tokens e mostrando LoginDialog forçando re-authentication, API client requests.Session() configurado com base_url = GEOAPI_URL, session.headers.update({ 'Authorization': f'Bearer {auth_manager.getAccessToken()}' }) adding header antes de cada request, retry strategy com urllib3.util.retry.Retry(total=3, backoff_factor=1, status_forcelist=[429, 500, 502, 503, 504]) handling transient failures, timeout configurado session.request(method, url, timeout=30) prevenindo hangs indefinidos, error handling try/except requests.exceptions.HTTPError catching 401 Unauthorized triggering token refresh retry uma vez, se falha novamente força logout, service account configuration no Keycloak client settings com Service Accounts Enabled: ON, Valid Redirect URIs: http://localhost:8888/callback para browser flow, Web Origins: *, Access Type: confidential, client secret gerado copiado para plugin settings, user account flow melhor para audit porque logs mostram which user performed action ao invés de generic service account, mas service account útil para operações automated scheduled tasks sem user presence.
