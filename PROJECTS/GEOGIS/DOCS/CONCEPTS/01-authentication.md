Authentication no GEOGIS Python plugin oferece dois modos sendo Service Account mode usando Client Credentials Flow ideal para scripts automatizados batch processing sem user interaction onde token = keycloak_openid.token(grant_type='client_credentials') faz POST ao token endpoint com client_id e client_secret obtendo access_token sem authorization code flow client secret armazenado em QSettings encrypted via QGIS password manager token renovado automaticamente quando expira checking expires_in claim usado para operações scheduled tasks nightly sync bulk export reports sem user presente.

User Account mode usando Authorization Code + PKCE Flow para operations requiring user context audit logs showing who performed action implementado gerando code_verifier random com secrets.token_urlsafe(64) calculando code_challenge SHA256 hash construindo auth_url com parameters client_id redirect_uri=http://localhost:8888/callback response_type=code scope=openid profile email code_challenge code_challenge_method=S256 abrindo browser com webbrowser.open(auth_url) que navega usuário para Keycloak login screen iniciando local HTTP server com http.server.HTTPServer(('localhost', 8888), CallbackHandler) listening em porta 8888 aguardando callback CallbackHandler extends BaseHTTPRequestHandler implementando do_GET() que extrai code da URL query params salva em variable accessible ao main thread retorna 200 OK com HTML message "Login successful! You can close this window" server shutdown após single request.

Main thread exchange code por tokens fazendo POST ao token endpoint com grant_type=authorization_code client_id code code_verifier original unhashed redirect_uri response JSON parsed extraindo access_token refresh_token expires_in armazenamento tokens via QSettings.setValue('access_token', token) encrypted QSettings.setValue('refresh_token', refresh_token) encrypted self.expires_at = datetime.now() + timedelta(seconds=expires_in) token refresh implementado em getAccessToken() checking if datetime.now() < self.expires_at - timedelta(minutes=1) retorna cached senão faz refresh com keycloak_openid.refresh_token(refresh_token) POST ao token endpoint se refresh sucesso atualiza tokens e expires_at se falha session expirou força logout() limpando QSettings e mostrando LoginDialog novamente.

API requests usam token via requests.Session().headers.update Authorization Bearer auth_manager.getAccessToken adicionando header automaticamente retry logic se 401 Unauthorized tenta refresh uma vez se falha força re-authentication logout implementado com keycloak_openid.logout(refresh_token) POST ao logout endpoint invalidando sessão depois QSettings.remove('access_token') QSettings.remove('refresh_token') self.access_token = None cleaning state mode selection via Settings dialog radio buttons "Service Account (automated)" vs "User Account (interactive)" saving preference em QSettings plugin checks mode on startup restaurando session appropriate flow.
