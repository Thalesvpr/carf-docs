# Offline Sync Workflow (Sincronização Offline Bidirecional)

Workflow completo de sincronização bidirecional entre banco de dados local no aplicativo mobile e banco de dados central no backend permitindo field agents trabalharem completamente offline coletando dados de Units Holders Documents em campo sem conexão retornando para área com WiFi e sincronizando automaticamente resolvendo conflitos via estratégias configuráveis por tipo de entidade. Arquitetura implementa sync engine baseado em timestamps e version vectors onde cada registro tem created_at updated_at deleted_at (soft delete) e _synced_at marcando última sincronização bem-sucedida, backend expõe endpoint de pull incremental retornando changesets de todas entidades modificadas após timestamp fornecido e endpoint de push recebendo array de mudanças locais aplicando no servidor e retornando conflicts detectados para resolução no cliente. Pull inicial ao abrir app consulta timestamp de última sincronização local e requisita changesets desde aquele momento recebendo estrutura de dados contendo arrays de units holders documents communities modificados e IDs de registros deletados onde cliente aplica changesets via operações batch atualizando registros existentes inserindo novos e deletando removidos marcando todos com timestamp atual de sincronização, e interface exibe progress bar com contadores de registros sincronizados. Edições offline são tracked localmente via status enum (SYNCED LOCAL_CREATED LOCAL_UPDATED LOCAL_DELETED) onde SYNCED indica registro em sync com servidor, LOCAL_CREATED para Units/Holders criados offline ainda não enviados ao servidor gerando identificador temporário único, LOCAL_UPDATED para edições em registros já existentes, e LOCAL_DELETED para soft deletes locais pendentes de propagação, badge visual no app mostra contador de pendentes de sincronização incentivando usuário a conectar quando possível. Push de mudanças ao detectar conectividade agrupa mudanças locais por status filtrando não-sincronizados monta payload estruturado com arrays de criados atualizados deletados incluindo metadados de dispositivo usuário e timestamp envia com retry exponential backoff até 5 tentativas, backend processa batch dentro de transação validando permissões via controle de acesso por linha verificando conflicts comparando timestamps local vs servidor aplicando changes se válidos retornando resposta com IDs sincronizados e lista de conflitos onde conflicts contém registros que falharam por edição concorrente. Conflict detection compara version vectors onde conflict ocorre se servidor foi editado após último pull do cliente indicando edição concorrente, tipos de conflict incluem UPDATE_UPDATE (ambos editaram mesmo registro), DELETE_UPDATE (cliente editou mas servidor deletou), CREATE_DUPLICATE (cliente criou mas servidor já tem registro com mesmo código/CPF), e SCHEMA_MISMATCH (cliente usando versão antiga de schema incompatível com servidor), cada conflict é retornado ao cliente com dados completos de ambas versões permitindo resolução informada. Resolution strategies são configuráveis por entidade onde Units usa MANUAL_REVIEW exibindo tela de merge permitindo field agent escolher qual versão manter ou mesclar campos manualmente salvando resultado como LOCAL_UPDATED para re-push, Holders usa SERVER_WINS descartando edição local e aceitando versão servidor automaticamente já que cadastro de titular é crítico e versão servidor presumivelmente passou por validação de gestor, Documents usa CLIENT_WINS pois fotos capturadas offline são únicas e servidor nunca deve sobrescrever, Communities usa SERVER_WINS pois boundaries são definidos por gestor municipal não field agent, e Annotations usa MERGE_BOTH preservando ambas versões criando Annotation duplicada com prefixo [CONFLITO] para revisão posterior. Edge cases tratados incluem criação offline de Unit com Holders onde identificadores temporários são substituídos por IDs definitivos do servidor após push mantendo foreign keys consistentes via tabela de mapeamento local, falha de upload de fotos onde Documents com anexos grandes são enfileirados separadamente com retry individual e tracking de progresso, interrupção parcial de sync onde changesets são aplicados atomicamente via transações permitindo resume do ponto de falha sem duplicação, diferença de relógio entre dispositivo e servidor onde timestamps são normalizados via header de tempo do servidor ajustando offsets locais, e edições concorrentes por múltiplos field agents na mesma Community resolvidos via last-write-wins per-field granular merge onde campos diferentes podem vir de usuários diferentes baseado em timestamps individuais de cada campo. Performance otimizations incluem delta sync enviando apenas campos modificados ao invés de registro completo reduzindo payload em 60-80%, compressão de payloads grandes, batching de até 100 registros por requisição evitando timeouts, e background sync ativando automaticamente quando app detecta conectividade sem intervenção do usuário exibindo apenas notificação de conclusão. Auditoria completa de sync registra em tabela SyncLog local contendo identificador de sync timestamp direção (PULL/PUSH) status (SUCCESS/PARTIAL/FAILED) contagem de registros contagem de conflitos mensagem de erro permitindo troubleshooting de problemas e exibição de histórico de sincronizações em tela de configurações do app com botão para forçar sincronização completa resetando timestamps e re-baixando todos dados em caso de corrupção local.

**Implementações por projeto:**
- Backend .NET: (caminho de implementação) (endpoints de sincronização)
- Mobile React Native: (caminho de implementação) (engine de sincronização local)
- Database: (caminho de implementação) (metadados de sync)

---

**Última atualização:** 2025-01-05
**Status do arquivo**: Review
