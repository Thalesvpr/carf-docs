# Clean Architecture

Clean Architecture organiza GEOAPI em camadas concêntricas com dependências apontando sempre para dentro garantindo testabilidade e manutenibilidade conforme [ADR-008: Clean Architecture + DDD](../ADRs/ADR-008-clean-architecture-ddd.md). Domain (núcleo) contém entities ([Unit](../../DOMAIN-MODEL/ENTITIES/02-unit.md), [Holder](../../DOMAIN-MODEL/ENTITIES/03-holder.md), [Community](../../DOMAIN-MODEL/ENTITIES/04-community.md) herdam BaseEntity), value objects imutáveis (CPF, Email, GeoPolygon) documentados em [@carf/tscore Value Objects](../../../PROJECTS/LIB/TS/TSCORE/DOCS/CONCEPTS/01-value-objects.md), domain events (UnitCreatedEvent, HolderLinkedEvent) conforme [ADR-010: Event-Driven](../ADRs/ADR-010-event-driven-architecture.md), e exceptions de negócio (ValidationException, ConflictException), completamente puro sem dependências NuGet nem frameworks. Application orquestra use cases via [CQRS](./02-cqrs.md) com command handlers (CreateUnitCommandHandler modificando estado), query handlers (GetUnitByIdQueryHandler retornando DTOs), interfaces de portas (IUnitRepository via [Repository pattern](./03-repository-uow.md), IEmailService, ITenantProvider extraindo de JWT claims conforme [ADR-005: RLS](../ADRs/ADR-005-multi-tenancy-rls.md)), e pipelines MediatR cross-cutting (logging, validation, transaction). Infrastructure implementa adaptadores concretos (UnitRepository usando EF Core conforme [ADR-001: .NET 9](../ADRs/ADR-001-dotnet-9-backend.md), EmailService usando SendGrid, TenantProvider extraindo de JWT claims), migrations database, configurações DI, e integrações externas ([Keycloak](../ADRs/ADR-003-keycloak-autenticacao.md), RabbitMQ). Gateway (API layer) traduz HTTP para comandos/queries sem lógica negócio, controllers magros delegando para MediatR, DTOs request/response mapeados via AutoMapper, e middleware tratando autenticação/autorização/exception handling. Regra de dependência: Domain não conhece ninguém, Application depende só de Domain, Infrastructure depende de Application/Domain, Gateway depende de tudo mas é thin layer substituível.

## Implementação

Pattern implementado no backend GEOAPI estruturado em 4 layers físicas separadas (Domain.csproj, Application.csproj, Infrastructure.csproj, Gateway.csproj) compilando em assemblies distintos enforcement de regra de dependência via project references unidirecionais bloqueando circular dependencies em build time, Domain layer contém [aggregates](../../DOMAIN-MODEL/AGGREGATES/README.md) como [UnitAggregate](../../DOMAIN-MODEL/AGGREGATES/01-unit-aggregate.md) encapsulando invariantes de negócio, Application layer implementa [CQRS pattern](./02-cqrs.md) separando leitura/escrita, Infrastructure layer integra com [PostgreSQL+PostGIS](../ADRs/ADR-002-postgresql-postgis.md) via EF Core e Keycloak para autenticação, e Gateway layer expõe REST API documentada em [CENTRAL/API](../../API/README.md) consumida pelos frontends GEOWEB, REURBCAD e ADMIN.

---

**Última atualização:** 2026-01-10
