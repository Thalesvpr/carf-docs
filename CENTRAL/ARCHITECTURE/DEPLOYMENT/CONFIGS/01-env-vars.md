# VARIÁVEIS DE AMBIENTE

Sistema CARF requer configuração de variáveis de ambiente específicas por projeto organizadas por componente facilitando deploy em diferentes ambientes como desenvolvimento staging e produção onde cada aplicação possui conjunto próprio de variáveis obrigatórias e opcionais com valores default documentados permitindo configuração consistente da infraestrutura evitando erros de deployment e garantindo separação adequada entre ambientes com secrets gerenciados externamente via Azure Key Vault ou AWS Secrets Manager nunca commitados em repositório Git seguindo práticas de segurança industry standards para proteção de credenciais sensíveis tokens de API e connection strings de banco de dados. Projeto GEOAPI backend .NET requer variável obrigatória DATABASE_URL contendo connection string PostgreSQL no formato postgres://usuario:senha@host:porta/database apontando para database primário da aplicação com connection pooling gerenciado por Entity Framework Core usando max pool size padrão de cem conexões e timeout de trinta segundos, variável KEYCLOAK_URL obrigatória definindo base URL do servidor Keycloak formato http://host:porta para desenvolvimento como http://keycloak:8080 ou https://keycloak.carf.example.com para produção usado para autenticação OAuth2 validação de tokens JWT e federação de identidade, KEYCLOAK_REALM obrigatória especificando nome do realm como carf case-sensitive identificando configuração de tenant isolation com clients roles e permissions separados, KEYCLOAK_CLIENT_ID obrigatória identificando client confidencial como geoapi-backend usado para obter tokens via service account e validar tokens de incoming requests verificando audience claim, JWT_SECRET obrigatória contendo chave criptográfica de duzentos e cinquenta e seis bits em formato base64 usada para assinar tokens refresh customizados complementares aos Keycloak access tokens devendo ser rotacionada trimestralmente em produção e gerada via comando openssl rand menos base64 trinta e dois. Variáveis opcionais do GEOAPI incluem REDIS_URL para connection string Redis formato redis://host:porta ou redis://:senha@host:porta se autenticação habilitada com default localhost porta seis mil trezentos e setenta e nove usado para cache distribuído session storage rate limiting pub/sub notifications com timeout de cinco segundos, RABBITMQ_URL para mensageria assíncrona formato amqp://usuario:senha@host:porta com default localhost cinco mil seiscentos e setenta e dois usado para domain events background jobs e integration events com retry exponential backoff, LOG_LEVEL enum aceitando valores debug info warn error com default info em desenvolvimento debug em produção warn controlando verbosity de logging Serilog com structured logging direcionado para sinks console file e Seq opcional para monitoramento centralizado, ASPNETCORE_ENVIRONMENT obrigatória enum Development Staging Production controlando comportamento runtime como exception pages CORS policies HTTPS redirection e aplicação automática de database migrations em Development mas manual em Staging e Production, ASPNETCORE_URLS definindo bind URLs formato http://mais:porta com default http://localhost:5000 em desenvolvimento e http://mais:8080 em containers Docker permitindo override de porta binding, CORS_ORIGINS lista comma-separated de origins permitidos formato http://localhost:3000,https://geoweb.carf.example.com com default asterisco em desenvolvimento mas específico em produção para security validação de CORS policy e preflight requests, ENABLE_SWAGGER boolean habilitando Swagger UI endpoint /swagger com documentação OpenAPI 3.0 e interactive testing default true em Development mas false em Production por security, DATABASE_COMMAND_TIMEOUT segundos para timeout de comandos database default trinta podendo aumentar para cento e vinte em operações batch como reports generation e spatial queries complexas PostGIS, SMTP_HOST servidor SMTP opcional formato smtp.sendgrid.net usado para envio de emails como notificações redefinição de senha boas-vindas e relatórios gerados com SMTP_PORT default quinhentos e oitenta e sete para TLS quatrocentos e sessenta e cinco para SSL evitando vinte e cinco inseguro, S3_BUCKET_NAME nome do bucket AWS S3 para armazenamento de documentos uploads fotos de units e relatórios PDF gerados opcional com fallback para filesystem local em desenvolvimento mas obrigatório em produção para escalabilidade com S3_REGION especificando região AWS como us-east-1 ou sa-east-1, ENABLE_AUDIT_LOG boolean habilitando audit log completo de operações CRUD default true em produção false em desenvolvimento devido performance overhead com async write para tabela PostgreSQL audit_logs garantindo compliance LGPD e rastreabilidade, SENTRY_DSN Data Source Name Sentry para error tracking formato https://chave@sentry.io/projeto opcional em produção para monitoramento de erros alertas real-time e integração com Slack ou PagerDuty, HANGFIRE_DASHBOARD_ENABLED boolean habilitando Hangfire Dashboard UI para background jobs default true em desenvolvimento false em produção por security com acesso restrito a VPN. Projeto GEOWEB frontend React requer VITE_API_URL obrigatória contendo base URL do backend GEOAPI formato http://host:porta/api como http://localhost:5000/api em desenvolvimento ou https://api.carf.example.com/api em produção usado em todas chamadas do Axios HTTP client configurado com baseURL interceptors para refresh token e automatic retry em 401 unauthorized, VITE_KEYCLOAK_URL obrigatória apontando para Keycloak usado na inicialização da biblioteca keycloak-js para SSO login logout token refresh e PKCE flow, VITE_KEYCLOAK_REALM obrigatória valor carf e VITE_KEYCLOAK_CLIENT_ID obrigatória valor geoweb-spa identificando client type public com PKCE enabled e redirect URIs configurados no Keycloak, VITE_ENABLE_MOCK_API boolean habilitando mock API via MSW Service Workers em desenvolvimento default false útil para desenvolvimento offline e testes E2E Playwright sem dependência de backend real usando fixtures JSON e faker para dados, VITE_MAP_TILE_URL especificando URL do tile server OpenStreetMap formato https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png com default OSM public tiles mas opcional self-hosted tile server em produção para rate limiting e cache via CDN CloudFront, VITE_MAP_DEFAULT_CENTER_LAT latitude do centro inicial do mapa default menos vinte e três ponto cinco cinco zero cinco dois zero São Paulo ajustável para município predominante do deployment geograficamente relevante para UX com VITE_MAP_DEFAULT_CENTER_LNG longitude default menos quarenta e seis ponto seis três três três zero oito e VITE_MAP_DEFAULT_ZOOM nível de zoom inicial default treze range um a vinte ajustável conforme contexto visualização cidade treze estado oito país cinco, VITE_SENTRY_DSN opcional para error tracking frontend capturando erros JavaScript runtime unhandled promises e React error boundaries com source maps upload por release para identificar stack traces, VITE_GOOGLE_ANALYTICS_ID formato G-XXXXXXXXXX opcional para métricas de uso page views eventos custom user journey e funnel de conversão, VITE_ENABLE_DEVTOOLS boolean habilitando Redux DevTools e React Query DevTools default true em desenvolvimento false em produção por security e performance, VITE_API_TIMEOUT_MS timeout em milissegundos para requests API default trinta mil podendo aumentar para sessenta mil em operações longas como report generation e batch operations, VITE_PAGINATION_PAGE_SIZE itens por página em listagens default vinte ajustável para dez em mobile cinquenta em desktop balanceando UX e performance trade-off. Projeto REURBCAD mobile React Native requer API_URL obrigatória formato http://host:porta/api como http://192.168.1.100:5000/api em desenvolvimento via rede local ou https://api.carf.example.com/api em produção usado para sincronização de dados units holders communities em arquitetura offline-first com WatermelonDB SQLite local e sync batch uploads, KEYCLOAK_URL obrigatória para login SSO mobile com deep linking redirect carf://oauth/callback configurado no identity provider, KEYCLOAK_REALM obrigatória valor carf e KEYCLOAK_CLIENT_ID obrigatória valor reurbcad-mobile configurado como public client com PKCE para mobile OAuth2 flow, SYNC_INTERVAL_MINUTES intervalo em minutos para sincronização automática em background default trinta ajustável para quinze com conectividade boa ou sessenta para economia de bateria com offline detection via NetInfo listener React Native cancelando sync e aguardando reconexão, STORAGE_PATH caminho do diretório para armazenamento SQLite WatermelonDB default DocumentDirectory em iOS e Android app-specific storage com scoped storage Android 10 plus migrando legacy paths, ENABLE_GPS_AUTO_CAPTURE boolean habilitando captura automática de GPS ao criar unit default true podendo desabilitar para economia de bateria ou quando precisão está baixa e usuário prefere entrada manual de coordenadas, GPS_ACCURACY_THRESHOLD_METERS threshold de precisão GPS mínima aceita em metros default dez rejeitando leituras com accuracy maior que dez metros aguardando sinal melhor com timeout trinta segundos e fallback manual, PHOTO_MAX_RESOLUTION largura máxima de fotos capturadas em pixels default mil novecentos e vinte podendo reduzir para mil duzentos e oitenta para economia de storage e bandwidth no upload sync com compressão JPEG quality oitenta preservando EXIF orientation, PHOTO_COMPRESSION_QUALITY qualidade de compressão JPEG range zero ponto zero a um ponto zero default zero ponto oito balanceando qualidade e tamanho de arquivo mantendo legibilidade de documentos e fachadas, ENABLE_OFFLINE_MAPS boolean habilitando download de offline tiles do mapa com cache local default false opcional para usuários em campo sem conectividade sendo storage intensivo aproximadamente quinhentos megabytes por cidade média com tiles zoom dez a dezoito, OFFLINE_MAPS_MAX_ZOOM zoom máximo para tiles download offline default dezoito podendo reduzir para dezesseis para economia de storage balanceando detalhe, ENABLE_CRASH_REPORTING boolean habilitando crash reporting via Sentry ou Bugsnag default true em produção false em desenvolvimento respeitando privacy LGPD compliance com opt-in do usuário, ENABLE_ANALYTICS boolean habilitando analytics Firebase ou Google Analytics para eventos custom default true em produção com opt-in LGPD e termo de aceite, LOG_LEVEL enum debug info warn error default info em desenvolvimento debug em produção warn com Reactotron em desenvolvimento para remote debugging, API_RETRY_ATTEMPTS tentativas de retry para requests falhados por network timeout default três com exponential backoff um segundo dois segundos quatro segundos cancelando se offline persistente e queueing retry para reconexão, API_TIMEOUT_MS timeout para requests API default trinta mil aumentando para sessenta mil em uploads de fotos e batch sync de múltiplas units, ENABLE_BIOMETRIC_AUTH boolean habilitando autenticação biométrica FaceID TouchID fingerprint Android default true opcional após primeiro login SSO com cache de credentials encrypted via Keychain iOS e KeyStore Android, SESSION_TIMEOUT_MINUTES minutos de inatividade para logout automático default trinta por security compliance podendo ajustar para sessenta para técnicos de campo com trocas de contexto frequentes evitando re-login constante e UX friction. Projeto GEOGIS plugin QGIS Python requer API_URL obrigatória para comunicação HTTP requests do plugin QGIS desktop application formato http://localhost:5000/api em desenvolvimento ou https://api.carf.example.com/api em produção com network access e firewall rules permitindo QGIS PyQt5 QNetworkAccessManager com SSL verification, KEYCLOAK_URL obrigatória para login SSO desktop com OAuth2 desktop flow redirect http://localhost:8090/callback usando local HTTP server temporário para capturar authorization code, KEYCLOAK_REALM obrigatória valor carf e KEYCLOAK_CLIENT_ID obrigatória valor geogis-desktop configurado como confidential client para desktop application com client secret embedded ofuscado mas não seguro cem por cento com warning para usuários, QGIS_PLUGIN_DIR caminho de instalação do plugin QGIS default ~/.local/share/QGIS/QGIS3/profiles/default/python/plugins/carf-geogis em Linux e %APPDATA%\QGIS\QGIS3\profiles\default\python\plugins\carf-geogis em Windows permitindo override para instalações custom com profiles múltiplos, ENABLE_DEBUG_LOGGING boolean habilitando logging debug verbose para QGIS message log default false em desenvolvimento true para debug e investigação de erros PyQGIS API via QgsMessageLog, LAYER_REFRESH_INTERVAL_SECONDS intervalo em segundos para refresh automático de layers com PostgreSQL connection para units holders communities e real-time updates default sessenta ajustável para trinta em ambiente colaborativo com múltiplos usuários editando simultaneamente ou trezentos para economia de recursos e database load, POSTGRES_CONNECTION_TIMEOUT timeout em segundos para connection PostgreSQL direct connection como alternativa a REST API para queries espaciais complexas ST_Intersects ST_Buffer e analysis tools QGIS Processing default dez aumentando para trinta com network latency ou VPN, ENABLE_SPATIAL_INDEX_CACHE boolean habilitando cache local de spatial indexes em GeoPackage para otimização de queries com repeated ST_Contains checks melhorando rendering performance default true em desenvolvimento e produção, TEMP_LAYER_STORAGE_PATH caminho do diretório para storage de layers temporários GeoPackage como scratch workspace para análises intermediárias default sistema temp dir com override para SSD melhorando performance em disk I/O intensivo. Projeto WEBDOCS portal VitePress requer VITE_BASE_URL caminho base para deploy em GitHub Pages S3 CloudFront formato /carf-docs/ como subpath ou https://docs.carf.example.com/ para custom domain com default / para root deployment obrigatório na config VitePress base option garantindo assets e links relativos ou absolutos corretos para routing SPA, VITE_ALGOLIA_APP_ID ID da aplicação Algolia DocSearch para indexação de busca full-text na documentação opcional em produção melhorando UX comparado a search nativo VitePress limitado com Algolia crawler automático scraping site e indexing real-time, VITE_ALGOLIA_API_KEY API key search-only Algolia público safe para embed no frontend e VITE_ALGOLIA_INDEX_NAME nome do index Algolia default carf-docs permitindo separar ambientes staging e produção, VITE_GOOGLE_ANALYTICS_ID para GA4 tracking opcional com métricas de acesso páginas mais visitadas search queries segmentando usuários públicos e internos, VITE_ENABLE_EDIT_LINK boolean habilitando links Edit this page no rodapé de páginas redirecionando para GitHub source markdown permitindo contribuições via pull requests default true para interno false para público read-only, GITHUB_REPO_URL URL do repositório GitHub formato https://github.com/org/carf-docs usado para construir edit links issue reporting e feedback, SYNC_CRON_SCHEDULE cron expression para agendamento de sincronização automática docs CENTRAL para repositório carf-docs formato 0 2 * * * executando diariamente às duas da manhã UTC via CI/CD GitHub Actions workflow trigger fetching latest markdown rebuild e deploy, FILTER_PRIVATE_CONTENT boolean habilitando filtro de remoção de conteúdo privado via script filter-private.js em build time parsing frontmatter YAML com flag private: true para seções sensíveis SECURITY/INCIDENTS credenciais e IPs internos default true para público false para build interno completo, ENABLE_MERMAID_DIAGRAMS boolean habilitando plugin Mermaid para rendering de diagramas em markdown default true sendo diagramas ER workflows state machines e architecture essenciais para visual documentation, ENABLE_DARK_MODE boolean habilitando tema escuro com toggle default true para acessibilidade e preferência do usuário com persistência em localStorage, CONTENT_SOURCE_PATH caminho source da documentação markdown default ../../CENTRAL relativo a WEBDOCS/SRC-CODE apontando para CENTRAL via symlink ou alternativa copy em build time com sync script automation. Gerenciamento de secrets estabelece que variáveis marcadas com asterisco são obrigatórias em todos ambientes sem valores default onde aplicação falha no startup com validação em Program.cs lançando exception indicando missing required configuration facilitando troubleshooting, secrets sensíveis como passwords API keys connection strings de database e JWT secrets nunca devem ser commitados em repositório Git com .gitignore incluindo .env .env.local e .env.*.local sendo arquivos de desenvolvimento local devendo usar .env.example como template com placeholders <REPLACE_WITH_ACTUAL_VALUE> para documentação, ambientes staging e produção devem usar gerenciadores de secrets cloud como Azure Key Vault provendo armazenamento centralizado de secrets com acesso controlado via RBAC Azure AD service principals e managed identities permitindo injeção runtime de variáveis de ambiente em Kubernetes pods via annotations secrets-store-csi-driver com sincronização automática rotação trimestral audit logs e compliance ou AWS Secrets Manager com funcionalidade similar incluindo Lambda rotation policies KMS encryption IAM roles e EKS pods service accounts IRSA injection em containers via environment variables ou volumes mounted em /mnt/secrets read-only, CI/CD pipelines via GitHub Actions devem usar secrets em repository settings com encrypted variables em workflows acessíveis em jobs e steps mas never echo ou print em logs sendo masked automatically prevenindo exposing secrets em build logs e artifacts, desenvolvimento local requer desenvolvedores criarem .env.local próprio gitignored copiando .env.example e preenchendo com valores de desenvolvimento inseguros como passwords simples dev_password URLs localhost e mock APIs nunca usando produção credentials em desenvolvimento evitando contaminação entre ambientes com separação estrita de networks databases e tenants, rotation de secrets em produção segue política trimestral para JWT_SECRET database passwords e API keys externos coordenando com equipe DevOps SRE comunicando com antecedência de duas semanas planejando janela de manutenção com downtime zero via rolling restart de pods Kubernetes após secrets updated e ConfigMap reload com graceful shutdown SIGTERM handling, validação de formato de variáveis ocorre no startup da aplicação com regex parsing de URLs verificação de conectividade com dependencies via health checks PostgreSQL Redis Keycloak usando retry exponential backoff com timeout de trinta segundos e fail fast com exception clara em logs indicando variável inválida ou missing facilitando troubleshooting de deployment failures e pods CrashLoopBackOff permitindo investigate via logs acessados com kubectl logs nome-pod nome-container.

---

**Última atualização:** 2026-01-10
**Status do arquivo**: Pronto
