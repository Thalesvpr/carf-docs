# ADR-006: Escolha de Arquitetura Offline-First com WatermelonDB

Decisão arquitetural escolhendo arquitetura offline-first para aplicativo mobile REURBCAD com WatermelonDB como database local justificada por requisito crítico de coleta de dados em campo em áreas rurais e comunidades periféricas sem cobertura celular confiável onde trabalho de técnicos não pode depender de conectividade intermitente sob risco de perda de produtividade e dados coletados, experiência de usuário superior com responsividade instantânea em todas operações (listagens buscas formulários) eliminando latência de rede e loading spinners frustrantes aumentando satisfação e adoção do app, resiliência a falhas de rede onde problemas de conectividade não bloqueiam trabalho permitindo técnicos continuarem cadastros mesmo durante interrupções temporárias ou degradação de sinal, economia de dados móveis reduzindo consumo de plano celular corporativo através de sincronização inteligente apenas de deltas e compressão de payloads importante para prefeituras com orçamento limitado, e escalabilidade melhorada desacoplando carga de leitura do backend onde milhares de consultas locais não geram tráfego no servidor reduzindo custos de infraestrutura e melhorando performance global do sistema.

WatermelonDB especificamente fornece database relacional completo baseado em SQLite com performance nativa executando queries complexas com joins e índices em milissegundos comparável a acesso direto ao PostgreSQL mas totalmente local, lazy loading automático de registros relacionados otimizando memória ao carregar apenas dados visíveis em tela evitando overhead de carregar grafos completos de objetos, observables reativos integrando nativamente com React através de hooks garantindo que UI atualiza automaticamente quando dados locais mudam sem código boilerplate de listeners, sync engine bidirecional robusto suportando conflict resolution automático para edições concorrentes do mesmo registro usando estratégias configuráveis (last-write-wins server-wins custom merge), migrations automáticas de schema permitindo evolução de modelo de dados em novas versões do app sem quebrar dados existentes em dispositivos antigos crítico para manutenção de longo prazo, performance otimizada para mobile com batch operations reduzindo overhead de I/O do SQLite e indexação inteligente mantendo queries sub-100ms mesmo com dezenas de milhares de registros locais, e integração nativa com React Native eliminando necessidade de bridges lentos entre JavaScript e SQLite usando JSI (JavaScript Interface) para acesso síncrono ao database.

Arquitetura offline-first implementada segue padrão onde app funciona 100% localmente em modo default lendo e escrevendo apenas no WatermelonDB local, sincronização ocorre em background automaticamente quando conectividade está disponível usando algoritmo pull-push onde primeiro baixa mudanças do servidor (pull) aplicando localmente e depois envia mudanças locais pendentes (push) resolvendo conflitos, timestamps de última modificação em cada registro permitem sincronização incremental evitando transfer de dataset completo e reduzindo payload em 95-99%, conflict resolution usa estratégia last-write-wins por default com fallback para manual resolution em casos críticos (exemplo duas edições concorrentes de geometria de unidade) marcando registro como conflicted e apresentando UI de merge para usuário, e queue persistente de operações pendentes garante que ações offline (criar unidade adicionar foto vincular titular) não sejam perdidas mesmo se app crashar antes de sincronizar.

Alternativas consideradas incluem Realm (rejeitado por sync engine proprietário exigindo Realm Cloud ou MongoDB Atlas com custos variáveis imprevisíveis além de limitações de queries complexas comparado a SQL completo), PouchDB/CouchDB (rejeitado por performance inferior em mobile devido a overhead de JSON e ausência de índices otimizados para queries espaciais além de tamanho de database crescendo indefinidamente sem compaction), AsyncStorage (rejeitado por ser key-value store simples sem suporte a queries complexas ou relacionamentos exigindo implementação manual de índices e joins impossível de escalar), SQLite raw via react-native-sqlite-storage (rejeitado por falta de sync engine exigindo implementação manual de sincronização conflitos e migrations além de ausência de reactive updates automáticos), e Firebase Realtime Database (rejeitado por exigir conectividade online para funcionalidade completa além de modelo de dados NoSQL limitado e custos por operação tornando inviável para uso intenso).

Consequências positivas incluem UX excepcional com app sempre responsivo independente de conectividade aumentando satisfação e produtividade de técnicos em campo, trabalho offline garantido permitindo coleta de dados em áreas remotas sem cobertura celular habilitando uso em 100% do território versus ~70% com abordagem online-only, resiliência a falhas de rede eliminando frustração de erros de timeout e perda de trabalho, economia de dados móveis reduzindo custo operacional de planos celulares corporativos, e escalabilidade melhorada descarregando leitura do backend. Consequências negativas incluem complexidade aumentada de sincronização exigindo lógica robusta de conflict resolution e tratamento de edge cases (exemplo registro deletado no servidor enquanto editado offline), overhead de armazenamento local com database SQLite crescendo até ~100-500MB após meses de uso exigindo estratégia de archival de dados antigos, debugging mais complexo com estados divergentes entre cliente e servidor dificultando reprodução de bugs, possibilidade de dados stale se usuário ficar offline por dias sem sincronizar potencialmente causando decisões baseadas em informação desatualizada (mitigado com indicadores visuais de última sync), e impossibilidade de features que exigem dados real-time absolutos (exemplo notificações instantâneas de aprovação) exigindo push notifications complementares.

Configuração específica escolhida utiliza WatermelonDB 0.27+ com JSI habilitado para performance máxima, SQLite como backend com WAL mode habilitado para melhor concorrência entre leitura e escrita, sync automático a cada 15 minutos quando conectado em WiFi ou manualmente via pull-to-refresh em celular para economizar dados, batch size de 500 registros por request de sync balanceando payload com número de requests, conflict resolution usando last-write-wins por default com UI de merge manual para conflitos em campos críticos (geometria status titular), e retention policy deletando registros locais mais antigos que 6 meses mantendo database compacto enquanto preserva dados recentes para acesso offline.

Status da decisão é aprovado e implementado desde início do projeto em 2024-Q3, com revisão prevista apenas se WatermelonDB demonstrar limitações críticas de performance ou sync (improvável dado adoção por apps enterprise como TrailGuide e ProductHunt) ou se surgir solução offline-first fundamentalmente superior.

## Implementação

Decisão implementada no projeto mobile [REURBCAD](../../../PROJECTS/REURBCAD/DOCS/ARCHITECTURE/01-overview.md) usando WatermelonDB como local database SQLite para armazenar unidades, holders e fotos coletadas offline em campo via use case [UC-004: Coletar Dados Campo Mobile](../../REQUIREMENTS/USE-CASES/UC-004-coletar-dados-campo-mobile.md), sincronização bidirecional com backend [GEOAPI](../../../PROJECTS/GEOAPI/DOCS/README.md) conforme [UC-005: Sincronizar Dados Offline](../../REQUIREMENTS/USE-CASES/UC-005-sincronizar-dados-offline.md) detectando conflitos via timestamps e resolvendo com estratégia last-write-wins documentada em [REURBCAD Data Flow](../../../PROJECTS/REURBCAD/DOCS/ARCHITECTURE/03-data-flow.md), models WatermelonDB gerados de types [@carf/tscore](../../../PROJECTS/LIB/TS/TSCORE/DOCS/README.md) garantindo consistência com backend.

---

**Data:** 2024-09-15
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + Mobile
**Última revisão:** 2025-01-05
