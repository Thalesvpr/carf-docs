# ADR-011: Biblioteca TypeScript Compartilhada @carf/tscore

Decisão arquitetural criando biblioteca TypeScript compartilhada @carf/tscore como NPM package publicado no GitHub Packages para eliminar duplicação de código entre projetos frontend TypeScript (GEOWEB React, ADMIN Next.js, WEBDOCS VitePress) centralizando autenticação Keycloak OAuth2/OIDC (client initialization, token management, refresh automático, role checking), value objects com validações brasileiras (CPF com algoritmo mod 11 completo conforme CENTRAL/BUSINESS-RULES/VALIDATION-RULES/cpf-validation.md rejeitando sequências conhecidas e validando dígitos verificadores, CNPJ com validação de check digits, Email RFC 5322, Phone formato brasileiro com DDD), types TypeScript do domínio (Unit, Holder, Community, Tenant com 36+ entities sincronizadas com backend .NET via C# → TS type generation), enums de workflow (UnitStatus com 6 estados DRAFT→PENDING→IN_REVIEW→APPROVED/REJECTED/REQUIRES_CHANGES, LegitimationStatus com 11 estados do processo REURB Lei 13.465/2017, Role com hierarquia 5 níveis SUPER_ADMIN→ADMIN→MANAGER→ANALYST→FIELD_AGENT), hooks React para autenticação (useAuth, useKeycloak, ProtectedRoute component), composables Vue 3 para autenticação (useAuth, initAuth), e DTOs para comunicação API (CreateUnitDto, UpdateHolderDto, etc) garantindo contratos type-safe entre frontend e backend eliminando erros runtime causados por dessincronia de tipos especialmente em campos obrigatórios vs opcionais que causavam crashes silenciosos em produção.

Arquitetura @carf/tscore implementada como NPM package com subpath exports permitindo importação modular (`@carf/tscore/validations`, `@carf/tscore/auth/react`, `@carf/tscore/auth/vue`, `@carf/tscore/types`) habilitando tree-shaking para eliminar código não utilizado reduzindo bundle size, peer dependencies opcionais para React 18 e Vue 3 onde projetos que não usam Vue não instalam suas dependências evitando bloat desnecessário, build com Bun bundler gerando ES modules + TypeScript declarations (.d.ts) para autocomplete IDE e type checking compile-time, publicação no GitHub Packages registry @carf scope com autenticação via GITHUB_TOKEN mantendo código privado da organização sem custos de registry privado externo, versionamento semântico estrito seguindo SemVer onde breaking changes em validations ou types incrementam MAJOR (ex: mudar CPF.validate() signature), novas entities ou value objects incrementam MINOR (ex: adicionar CREA value object), e bug fixes em algoritmos incrementam PATCH (ex: corrigir edge case em CNPJ validation), e CHANGELOG.md mantido atualizado documentando cada release com seções Added/Changed/Fixed/Removed facilitando migration guides para projetos consumidores saberem quais mudanças requerem updates em código.

Módulos implementados incluem `auth/` com KeycloakClient (OAuth2 authorization code + PKCE flow, token storage em localStorage, refresh automático 60s antes de expiry, logout com revogação de token), TokenManager (gerenciamento lifecycle tokens com expiresAt tracking e auto-refresh), RoleChecker (verificação hierárquica onde hasRolePermission(userRole: MANAGER, requiredRole: ANALYST) retorna true pois MANAGER >= ANALYST conforme RoleHierarchy mapping), React hooks onde useAuth() retorna {user, isLoading, isAuthenticated, login, logout, hasRole, hasPermission, getToken} consumindo AuthContext provido por AuthProvider wrapper que inicializa Keycloak client e provê estado para toda árvore de componentes, ProtectedRoute component que renderiza children apenas se isAuthenticated senão redireciona para /login verificando opcionalmente roles requeridas via prop `requiredRoles={[Role.ADMIN]}` bloqueando acesso a usuários sem permissão adequada, Vue composables onde useAuth() retorna reactive refs com mesmas funcionalidades adaptadas para Composition API do Vue 3, `validations/` com CPF class implementando algoritmo mod 11 completo com pesos decrescentes 10,9,8...2 para primeiro dígito verificador e 11,10,9...2 para segundo conforme especificação Receita Federal rejeitando sequências conhecidas 000.000.000-00 até 999.999.999-99, normalize() removendo pontuação, validate() static method para validar sem instanciar, format() retornando string formatada ###.###.###-##, CNPJ class com algoritmo similar usando pesos [5,4,3,2,9,8,7,6,5,4,3,2] para 12º dígito e [6,5,4,3,2,9,8,7,6,5,4,3,2] para 13º dígito validando 14 caracteres numéricos, Email class validando local part + @ + domain com pelo menos um ponto rejeitando formatos inválidos comuns mas sem complexidade excessiva de RFC 5322 completo que seria performance bottleneck, Phone class validando formato brasileiro (##) #####-#### com DDD de 11 a 99 e número 9 dígitos para celular ou 8 para fixo, e `types/` com interfaces TypeScript para todas 36+ entities do domínio sincronizadas com backend .NET onde C# models são convertidos manualmente para TS interfaces garantindo mesmos campos tipos nullability (string vs string | null) evitando erros compile-time quando backend retorna campo que frontend espera diferente, enums exportados como const enum para inlining valores reduzindo bundle size, DTOs separados em CreateDto (campos requeridos para POST), UpdateDto (campos opcionais para PATCH), WithRelations (entity + related entities populated), WithStats (entity + computed statistics) permitindo backend retornar shapes diferentes conforme query e frontend ter types corretos para cada caso.

Alternativas consideradas incluem duplicar código em cada projeto (rejeitado por manutenção insustentável onde bug fix em CPF validation requer PR em 3 repos diferentes aumentando risco de inconsistência e esquecimento causando comportamento divergente entre GEOWEB e ADMIN confundindo usuários), shadcn/ui approach copiando source code (rejeitado por impossibilitar updates centralizados e versionamento semântico claro onde projetos consumidores não saberiam quando breaking changes foram introduzidos), monorepo com workspace (rejeitado por requerer migração completa de polyrepo strategy existente e tooling complexo Nx/Turborepo aumentando build times e exigindo coordenação de deploys), e Git submodules (rejeitado por experiência developer terrível com comandos obscuros git submodule update --remote --merge e dificuldade de trabalhar em feature branch da lib enquanto testa em projeto consumidor simultaneamente).

Consequências positivas incluem eliminação total de duplicação de código reduzindo bugs causados por inconsistências entre projetos especialmente validações críticas como CPF/CNPJ que afetam compliance legal e qualidade de dados cadastrados, manutenção centralizada onde bug fix em validação ou novo campo em entity type requer apenas 1 PR em tscore seguido de bump version e `bun update @carf/tscore` em projetos consumidores propagando fix automaticamente, versionamento semântico explícito comunicando breaking changes através de MAJOR version evitando surpresas em production após update, type safety completa entre frontend e backend eliminando classes inteiras de bugs runtime especialmente null reference errors em campos opcionais que crasham aplicação silenciosamente sem logging adequado, onboarding acelerado de novos desenvolvedores que consultam API reference da lib vendo todos value objects entities enums disponíveis sem precisar descobrir código espalhado em múltiplos repositórios, testabilidade melhorada com suite de testes unitários centralizada validando edge cases de CPF/CNPJ/Email uma vez ao invés de duplicar testes em cada projeto, e reutilização de hooks/composables autenticação evitando reimplementar integração Keycloak OAuth2 flow complexo com PKCE token refresh role checking em cada novo projeto TypeScript.

Consequências negativas incluem overhead de publicação onde mudanças em tscore requerem build + test + npm publish + update em projetos consumidores ao invés de editar arquivo diretamente aumentando latência de feedback durante desenvolvimento ativo (mitigado por npm link durante desenvolvimento local permitindo testar mudanças antes publicar oficialmente), risco de breaking changes acidentais onde mudança aparentemente inócua em tscore type pode quebrar builds de múltiplos projetos consumidores exigindo coordenação de rollout (mitigado por CI/CD rodando testes de integration dos projetos consumidores contra versões candidate antes publish oficial), complexidade de debug quando erro ocorre dentro da lib publicada e desenvolvedor precisa clonar repo separado configurar environment e reproduzir issue (mitigado por sourcemaps publicados e linking fácil via npm link), dependência em registry externo GitHub Packages que se indisponível impede installs e builds de projetos (mitigado por cache local npm e fallback para registry público se necessário), e learning curve de convenções da lib como import paths corretos exports disponíveis APIs de cada module (mitigado por documentação completa em README, API reference gerado automaticamente, e examples em PROJECTS/TSCORE/DOCS/HOW-TO/).

Estratégia de publicação utiliza GitHub Actions workflow disparado automaticamente em push de tag semântico v*.*.* (ex: v0.1.0) que roda lint + tests + build + type checking garantindo qualidade antes publish, gera package tarball via `bun build && tsc --emitDeclarationOnly`, autentica GitHub Packages via secrets.GITHUB_TOKEN, executa `npm publish` com publishConfig registry apontando para https://npm.pkg.github.com/@carf, e cria GitHub Release automático com changelog extraído de CHANGELOG.md facilitando tracking de mudanças e linking para PRs relacionados. Projetos consumidores configuram .npmrc com `@carf:registry=https://npm.pkg.github.com` e `//npm.pkg.github.com/:_authToken=${GITHUB_TOKEN}` permitindo `bun install @carf/tscore` resolver pacote corretamente, importam módulos específicos via `import { CPF, CNPJ } from '@carf/tscore/validations'` habilitando tree-shaking, e atualizam versão via `bun update @carf/tscore` seguindo releases publicadas conferindo CHANGELOG.md para breaking changes e migration steps necessários.

Desenvolvimento local da lib segue workflow onde desenvolver feature nova em tscore envolve `cd PROJECTS/TSCORE/SRC-CODE`, implementar código em src/, adicionar testes em **tests**/*, rodar `bun test` validando todos 49+ testes passam incluindo edge cases críticos, testar em projeto consumidor via `npm link` criando symlink local evitando publish intermediário, fazer ajustes conforme feedback de integração, commitar seguindo Conventional Commits (feat/fix/docs), bump version em package.json seguindo semver, atualizar CHANGELOG.md, criar tag git `git tag v0.2.0`, push com `git push --follow-tags` disparando CI/CD que publica automaticamente, e finalmente `bun update @carf/tscore` em projetos consumidores para adotar nova versão.

Compatibilidade com projetos mantida através de peer dependencies `react: ^18.0.0` e `vue: ^3.0.0` marcadas como optional via peerDependenciesMeta permitindo GEOWEB instalar apenas React enquanto WEBDOCS instala apenas Vue sem conflitos, exports separados `auth/react` vs `auth/vue` evitando importação acidental de framework errado que causaria erro runtime, e type-only imports para entities evitando bundle bloat onde `import type { Unit } from '@carf/tscore/types'` não inclui código JS runtime apenas informações de tipo para TypeScript compiler validar correctness durante development mas eliminado completamente em production build.

Próximos passos incluem adicionar mais value objects conforme necessário (CREA para engenheiros responsáveis técnicos, GeoPoint para validação de coordenadas geográficas com bounds check Brasil, Address para endereços estruturados com validação de CEP), implementar GeoJSON helpers para manipulação de geometrias compartilhadas entre frontend e QGIS plugin evitando conversões manuais error-prone, adicionar API client helpers com interceptors padrão para adicionar Authorization header automaticamente retry logic error handling consistent notifications facilitando setup de novos projetos, considerar geração automática de types TypeScript a partir de C# models usando Typewriter ou similares eliminando conversão manual propensa a erros e garantindo sincronia perfeita entre backend e frontend, e avaliar performance de value objects em hot paths otimizando regex ou lazy validation se benchmarks indicarem bottleneck (improvável dado simplicidade de operações mas prudente monitorar).

Status da decisão é aprovado e implementado desde 2026-01-09, com revisão prevista trimestralmente para avaliar se overhead de manutenção de package separado justifica benefícios ou se crescimento de complexidade sugere migração para monorepo approach com tooling adequado, monitorar adoção em novos projetos TypeScript (futuro carf-admin Next.js deve consumir desde inception), e coletar feedback de desenvolvedores sobre pain points da lib como ergonomia de APIs dificuldade de debug imports confusos para iterar melhorias contínuas maximizando produtividade e satisfaction da equipe.

## Implementação

Decisão implementada pela biblioteca [@carf/tscore](../../../PROJECTS/LIB/TS/TSCORE/DOCS/README.md) exportando 33 types TypeScript representando entidades do sistema conforme [CENTRAL/DOMAIN-MODEL/](../../DOMAIN-MODEL/00-INDEX.md), Value Objects (CPF, CNPJ, Email, Coordinates) com validações built-in documentados em [TSCORE Value Objects](../../../PROJECTS/LIB/TS/TSCORE/DOCS/CONCEPTS/01-value-objects.md), KeycloakClient para autenticação OAuth2 + PKCE flow reutilizado pelos frontends [GEOWEB](../../../PROJECTS/GEOWEB/DOCS/README.md), [REURBCAD](../../../PROJECTS/REURBCAD/DOCS/README.md) e [ADMIN](../../../PROJECTS/ADMIN/DOCS/ARCHITECTURE/04-integration.md) eliminando duplicação de lógica auth e garantindo implementação correta uniform entre projetos, consumida também por [@carf/geoapi-client](../../../PROJECTS/LIB/TS/GEOAPI-CLIENT/DOCS/README.md) tipando requests/responses HTTP e [@carf/ui](../../../PROJECTS/LIB/TS/UI-COMPONENTS/DOCS/README.md) tipando props de componentes domain-specific (UnitCard, HolderCard).

---

**Data:** 2026-01-09
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + Frontend Team
**Última revisão:** 2026-01-09
