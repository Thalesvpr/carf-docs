# ADR-008: Escolha de Clean Architecture + Domain-Driven Design

Decisão arquitetural escolhendo Clean Architecture combinada com Domain-Driven Design (DDD) como padrão arquitetural do backend GEOAPI justificada por separação clara de responsabilidades em layers (Domain Application Infrastructure Presentation) facilitando manutenção evolutiva de sistema complexo com ~220 RFs e previsão de crescimento contínuo por anos, independência de frameworks mantendo domain logic puro sem acoplamento a Entity Framework ASP.NET ou bibliotecas específicas permitindo migration futura de tecnologias sem rewrite completo de regras de negócio, testabilidade superior com domain entities e use cases testáveis em isolamento sem dependências externas (database HTTP) acelerando TDD e garantindo coverage acima de 80% conforme RNF-076, modelagem rica de domínio usando conceitos DDD (Entities Value Objects Aggregates Domain Events) capturando precisamente complexidade de legitimação fundiária urbana com invariantes de negócio expressas em código type-safe reduzindo bugs lógicos, linguagem ubíqua compartilhada entre desenvolvedores e especialistas de domínio (advogados urbanistas técnicos fundiários) eliminando mal-entendidos através de terminologia consistente (Unit Holder Community Process Legitimation vs genéricos como Entity User Document), bounded contexts isolando subdomínios complexos (Cadastro Aprovação Relatórios GIS) com interfaces bem definidas permitindo equipes trabalhar independentemente sem conflitos de merge e facilitando futura migração para microservices se necessário, e aggregate roots garantindo consistency boundaries claras protegendo invariantes críticas (exemplo Unit só pode ser aprovada se tiver ao menos um Holder vinculado e geometria válida) através de encapsulation rigoroso evitando corrupção de dados.

Clean Architecture especificamente organiza código em círculos concêntricos onde dependencies apontam apenas para dentro garantindo que domain core não depende de nada externo, Domain layer contém entities value objects aggregates domain events e repository interfaces expressando regras de negócio puras sem infraestrutura, Application layer contém use cases (commands queries) implementando fluxos de negócio coordenando domain objects e chamando repositories através de interfaces mantendo testabilidade, Infrastructure layer implementa repository interfaces usando Entity Framework integra com PostgreSQL implementa adapters para APIs externas (Keycloak IBGE ViaCEP) e gerencia preocupações técnicas (cache logging tracing), e Presentation layer (Controllers DTOs) recebe requests HTTP mapeia para commands/queries delega para application layer e serializa responses mantendo API contracts separados de domain models evitando vazamento de detalhes internos.

Domain-Driven Design adiciona modelagem tática refinada usando entities para objetos com identidade única e ciclo de vida próprio (Unit Holder Community Process), value objects para conceitos sem identidade definidos apenas por atributos (CPF Address GeoPolygon UnitStatus) garantindo imutabilidade e validação no constructor, aggregates agrupando entities relacionadas com single entry point via aggregate root (Unit aggregate contendo UnitHolders Documents Annotations) garantindo consistency em operações que afetam múltiplas entities, domain events representando fatos do negócio (UnitCreated UnitApproved HolderLinked) permitindo decoupling entre aggregates e habilitando eventual consistency quando necessary, repositories abstraindo persistência de aggregates com interface domain-centric (GetById Save Remove) sem expor detalhes de SQL ou EF, e factories encapsulando lógica complexa de criação de aggregates validando invariantes iniciais.

Alternativas consideradas incluem Transaction Script (rejeitado por não escalar para domínio complexo resultando em anemic models com logic espalhada em services gigantes difíceis de manter), Active Record (rejeitado por acoplar domain logic a framework de persistência como Entity Framework dificultando testes e impedindo evolução independente), anemic domain model com rich services (anti-pattern rejeitado por colocar toda lógica em services violando encapsulation e criando god classes), microservices desde início (rejeitado por overhead prematuro sendo mais prudente monolith modular com bounded contexts bem definidos permitindo extração futura de microservices se escala exigir), e Event Sourcing puro (rejeitado por complexidade excessiva para CRUD-heavy application onde audit trail via soft deletes e domain events ocasionais é suficiente).

Consequências positivas incluem manutenibilidade excelente com código organizado logicamente facilitando onboarding e evolução de features, testabilidade superior com domain logic testável em isolation alcançando coverage de 85%+, proteção contra corrupção de domain através de encapsulation rigoroso e validações no constructor de value objects reduzindo bugs de estado inválido, linguagem ubíqua documentada em código através de naming consistente facilitando comunicação entre devs e stakeholders, independência de tecnologia permitindo trocar EF por Dapper ou PostgreSQL por SQL Server com impacto mínimo em domain layer, e preparação para eventual extração de microservices através de bounded contexts bem definidos. Consequências negativas incluem overhead inicial de estruturação em layers adicionando boilerplate comparado a ActiveRecord simples, curva de aprendizado de conceitos DDD (aggregates value objects domain events) exigindo treinamento de equipe não familiarizada, mapping overhead entre domain entities e DTOs em presentation layer adicionando código repetitivo (mitigado com AutoMapper), risco de over-engineering em domínios simples onde CRUD direto seria suficiente (não aplicável a CARF com domínio complexo), e performance ocasionalmente inferior a SQL otimizado manual devido a abstrações de repository (mitigado com CQRS queries otimizadas).

Implementação específica estrutura projeto GEOAPI em pastas Domain (entities VOs aggregates events interfaces) Application (use-cases commands queries DTOs) Infrastructure (repositories EF configurations external adapters) e Presentation (controllers), utiliza MediatR para dispatch de commands/queries desacoplando controllers de use-cases, FluentValidation para validação de input em DTOs mantendo domain puro, AutoMapper para mapping entre layers reduzindo boilerplate, e naming conventions seguindo ubiquitous language com termos do negócio (Unit não Property, Holder não Owner, Legitimation não Regularization).

Status da decisão é aprovado e implementado desde início do projeto em 2024-Q3, com revisão prevista apenas se domínio simplificar drasticamente tornando Clean Architecture overhead desnecessário (improvável) ou se surgir paradigma arquitetural fundamentalmente superior (improvável dado sucesso de Clean Arch em enterprise systems).

---

**Data:** 2024-09-15
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + Backend
**Última revisão:** 2025-01-05
**Última atualização:** 2026-01-15
**Status do arquivo**: Pronto
