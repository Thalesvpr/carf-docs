# ADR-007: Escolha do Bun como Runtime e Bundler

Decisão arquitetural escolhendo Bun como runtime JavaScript e bundler all-in-one para frontend GEOWEB substituindo stack tradicional Node.js + npm + Vite/Webpack justificada por performance dramaticamente superior com cold start ~3x mais rápido que Node.js e hot reload instantâneo sub-100ms versus 1-3 segundos do Vite melhorando drasticamente Developer Experience e ciclo de iteração durante desenvolvimento, bundler integrado eliminando necessidade de configuração complexa de Webpack ou Vite reduzindo surface de configuração em 80% e eliminando incompatibilidades entre ferramentas, package manager nativo substituindo npm/yarn com install 10-20x mais rápido especialmente em CI/CD onde cada build economiza 2-5 minutos reduzindo custo de infraestrutura e acelerando deployments, APIs Web-standard implementando fetch FormData WebSocket Request Response nativamente sem polyfills reduzindo bundle size e eliminando dependências como node-fetch axios form-data, TypeScript transpilation nativo sem necessidade de tsc ou babel acelerando builds em 3-5x e simplificando toolchain, test runner integrado compatível com Jest mas 10x mais rápido eliminando dependência externa e simplificando configuração de testes, e all-in-one toolchain reduzindo drasticamente npm dependencies de ~500+ pacotes em projeto típico Node.js para ~50 essenciais diminuindo attack surface de supply chain e simplificando auditorias de segurança.

Bun 1.0+ especificamente oferece compatibilidade completa com Node.js APIs permitindo uso de bibliotecas npm existentes sem modificação eliminando risco de ecosystem fragmentation, compatibilidade com package.json e node_modules padrão permitindo migration incremental sem rewrite completo de projeto, performance de runtime superior a Node.js V8 devido a uso de JavaScriptCore (engine do Safari) otimizado para startup rápido crítico em serverless e CLI tools, built-in support para TypeScript JSX CSS modules e mais sem configuração eliminando ~10 dependências de dev típicas, watch mode extremamente rápido com Hot Module Replacement sub-50ms versus 500ms-2s de Vite permitindo feedback instantâneo durante desenvolvimento, e zero-config defaults inteligentes permitindo começar projeto com bun init sem webpack.config.js vite.config.js babel.config.js simplificando onboarding de novos desenvolvedores.

Arquitetura de build implementada utiliza Bun bundler para production builds com tree-shaking automático code splitting e minification eliminando Webpack/Vite da stack, bun install para gerenciamento de dependências com global cache compartilhado entre projetos economizando disk space e acelerando installs subsequentes, bun run scripts substituindo npm run com overhead menor, bun test para testes unitários e integração com coverage integrado, e bun build --target=browser para gerar bundle otimizado com todas otimizações habilitadas por default.

Alternativas consideradas incluem Node.js + Vite (stack tradicional rejeitada por lentidão comparativa especialmente em cold starts e HMR além de complexidade de configuração), Node.js + Webpack (rejeitado por configuração notoriamente complexa e builds lentos tornando experiência de desenvolvimento frustrante), Node.js + esbuild (rejeitado por ser apenas bundler sem runtime completo exigindo Node.js separado e package manager adicional), Deno (rejeitado por incompatibilidade com ecosystem npm exigindo uso de npm: specifiers e ausência de bundler production-ready nativo), e pnpm + Vite (rejeitado por ainda ser stack multiferramenta com overhead de coordenação versus all-in-one do Bun).

Consequências positivas incluem Developer Experience excepcional com feedback instantâneo acelerando desenvolvimento em 30-40%, builds de CI/CD 3-5x mais rápidos reduzindo custo e time-to-deploy, simplificação radical de toolchain reduzindo package.json de 500+ para 50 deps essenciais facilitando manutenção, compatibilidade com ecosystem npm existente permitindo uso de React TanStack Query Zustand shadcn sem modificações, performance de runtime superior permitindo uso de Bun em backend scripts e tooling interno além de frontend, e zero-config defaults reduzindo barrier de entrada para novos desenvolvedores. Consequências negativas incluem maturidade inferior a Node.js podendo ter bugs edge cases não descobertos ainda (mitigado por comunidade ativa e releases frequentes), ecosystem de plugins menor comparado a Vite exigindo implementação customizada de algumas features específicas, documentação menos extensa que Node.js exigindo consulta a source code ocasionalmente, risco de breaking changes em versões futuras dado que Bun 1.0 é relativamente recente (Outubro 2023), e adoção ainda crescente significando menos Stack Overflow answers e recursos comparado a Node.js (mitigado por Discord ativo e GitHub issues responsivos).

Configuração específica escolhida utiliza Bun 1.0.20+ instalado globalmente via curl, bunfig.toml para configuração mínima de aliases e registry customizado se necessário, bun install --frozen-lockfile em CI para reproducible builds, bun build com configuração inline via CLI flags evitando arquivo de config complexo, sourcemaps habilitados em dev desabilitados em prod, e bun test com coverage threshold mínimo de 80% forçado em CI.

Monitoramento de performance implementa tracking de métricas de build time em CI alertando se ultrapassar threshold de 2 minutos indicando problema, comparison periódico de bundle size entre versões detectando regressões, e fallback plan documentado para migração de volta a Node.js + Vite se Bun demonstrar showstopper bugs (improvável mas prudente ter exit strategy).

Status da decisão é aprovado e implementado desde início do projeto em 2024-Q3, com revisão prevista anualmente para avaliar maturidade de Bun e considerar se benefícios ainda justificam riscos de adoção early-adopter ou se ecosystem convergiu para alternativa superior.

## Implementação

Decisão implementada em todas as bibliotecas TypeScript [@carf/tscore](../../../PROJECTS/LIB/TS/TSCORE/DOCS/ARCHITECTURE/05-deployment.md), [@carf/geoapi-client](../../../PROJECTS/LIB/TS/GEOAPI-CLIENT/DOCS/ARCHITECTURE/05-deployment.md) e [@carf/ui](../../../PROJECTS/LIB/TS/UI-COMPONENTS/DOCS/ARCHITECTURE/05-deployment.md) usando Bun como package manager (`bun install`) e bundler (`bun run build`) conforme setup environments documentados respectivamente em [TSCORE HOW-TO](../../../PROJECTS/LIB/TS/TSCORE/DOCS/HOW-TO/01-setup-dev-environment.md), [GEOAPI-CLIENT HOW-TO](../../../PROJECTS/LIB/TS/GEOAPI-CLIENT/DOCS/HOW-TO/01-setup-dev-environment.md) e [UI-COMPONENTS HOW-TO](../../../PROJECTS/LIB/TS/UI-COMPONENTS/DOCS/HOW-TO/01-setup-dev-environment.md), também adotado em frontends [GEOWEB](../../../PROJECTS/GEOWEB/DOCS/HOW-TO/02-build-and-run.md) e [ADMIN](../../../PROJECTS/ADMIN/DOCS/HOW-TO/02-build-and-run.md) substituindo npm/yarn.

---

**Data:** 2024-09-15
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + Frontend
**Última revisão:** 2025-01-05
