# ADR-009: Escolha do Padrão CQRS (Command Query Responsibility Segregation)

Decisão arquitetural escolhendo implementação de CQRS (Command Query Responsibility Segregation) no backend GEOAPI justificada por separação clara entre operações de escrita (commands) que modificam estado validando invariantes de negócio e operações de leitura (queries) otimizadas para apresentação permitindo queries performáticas denormalizadas sem comprometer integridade de domain model, performance de leitura superior usando queries SQL otimizadas diretas via Dapper ou views materializadas no PostgreSQL ao invés de forçar todas reads através de aggregates do DDD eliminando overhead de hydration de object graphs complexos e reduzindo latência de P95 de listagens em 60-70% conforme RNF-001, escalabilidade independente permitindo scale-out de read replicas do PostgreSQL para queries pesadas (dashboards relatórios exports) sem afetar write master mantendo performance de writes críticos, simplificação de queries complexas escrevendo SQL otimizado com joins CTEs window functions diretamente ao invés de construir com LINQ que gera SQL subótimo especialmente em queries espaciais com PostGIS, cache granular de queries sem invalidação complexa onde cada query pode ter estratégia de cache específica (dashboard cached 5min, listagem paginada cached 1min, detalhes sem cache) versus tentativa de cache em aggregate level que invalida frequentemente, security simplificada aplicando authorization apenas em command handlers para writes enquanto queries read-only tem regras mais relaxadas (exemplo qualquer analyst pode ler unidades mas apenas field_agent pode criar), auditoria facilitada onde commands são naturally auditable points de mudança de estado enquanto queries não exigem audit trail, e preparação para eventual consistency se escala futura exigir separação física de read e write databases com replicação assíncrona.

CQRS implementado no GEOAPI separa commands em Application/Commands com handlers validando business rules invocando domain aggregates e persistindo mudanças através de repositories retornando apenas success/failure ou ID de entidade criada, queries em Application/Queries usando Dapper direto contra PostgreSQL retornando DTOs read-only otimizados para UI evitando overhead de Entity Framework tracking e hydration de navigation properties, MediatR como bus unificado despachando commands e queries através de interface consistente IRequest<TResponse> mantendo controllers thin sem acoplamento direto a handlers, FluentValidation em command inputs garantindo validação básica (required fields formats ranges) antes de invocar domain evitando exceptions desnecessárias, e authorization policies específicas por command/query usando atributos [Authorize(Policy = "CanCreateUnit")] aplicados em handlers ou controllers.

Queries otimizadas implementam projections customizadas selecionando apenas colunas necessárias para cada tela UI (exemplo listagem de unidades retorna apenas id code address status sem carregar holders documents), joins otimizados com índices apropriados para queries frequentes especialmente spatial joins usando GiST indexes, paginação server-side obrigatória em todas listagens retornando PagedResult<T> com total count evitando load de datasets completos, e DTOs específicos por query (UnitListDto UnitDetailDto UnitMapMarkerDto) ao invés de single DTO universal evitando over-fetching de dados.

Commands implementam validação em múltiplas camadas com FluentValidation para shape de input em presentation, domain validation para business rules complexas (CPF válido geometria não auto-intersecting ao menos um holder vinculado), e database constraints como última linha de defesa, idempotency keys opcionais em commands críticos (aprovação de processos pagamentos) prevenindo duplicação em retries, e retorno minimal de apenas success flag e ID criado evitando serialização de aggregate completo economizando bandwidth.

Alternativas consideradas incluem repository pattern tradicional sem separação CQRS (rejeitado por forçar reads através de aggregates resultando em performance subótima especialmente em queries complexas com joins múltiplos), GraphQL para resolver N+1 queries (rejeitado por adicionar complexidade de schema definitions resolvers e DataLoader além de overhead de parsing GraphQL queries), stored procedures para queries complexas (rejeitado por dificultar versionamento testes e CI/CD além de acoplar lógica ao database), OData para queries flexíveis (rejeitado por expor estrutura interna de database e complexidade de implementar authorization granular), e full Event Sourcing com projections (rejeitado por complexidade excessiva onde CQRS simples com CRUD normal é suficiente).

Consequências positivas incluem performance de reads otimizada com queries SQL hand-tuned alcançando sub-100ms em P95 conforme RNF-001, simplicidade de queries complexas escrevendo SQL direto ao invés de LINQ complexo, escalabilidade de reads independente através de replicas sem afetar writes, cache granular por query type melhorando hit rate, authorization simplificada com policies específicas por operation type, e auditoria natural de commands sem overhead em queries. Consequências negativas incluem duplicação de models entre commands (domain aggregates) e queries (read DTOs) adicionando código repetitivo de mapping (mitigado com AutoMapper), complexidade conceitual de explicar CQRS para developers júnior não familiarizados com pattern, overhead de manter dois caminhos para mesma funcionalidade exigindo disciplina para não misturar reads e writes, risco de eventual consistency se implementar read database separado no futuro (não aplicável no momento com single database), e debugging mais complexo rastreando fluxo de commands através de MediatR handlers.

Implementação específica usa MediatR 12.x para command/query dispatch, Dapper 2.x para queries otimizadas com custom SQL, Entity Framework Core apenas para commands com change tracking habilitado, DTOs read-only (records C#) para queries evitando mutação acidental, validation pipeline com FluentValidation executado automaticamente via MediatR behaviors antes de handler, authorization verificada em behaviors também usando IAuthorizationService do ASP.NET Core, e caching strategy usando IDistributedCache (Redis) com keys específicos por query type e parameters.

Monitoramento implementa métricas separadas para commands (latency success rate errors) e queries (latency cache hit rate slow queries) no Application Insights permitindo otimização focada, alertas para queries lentas acima de 500ms indicando necessidade de índices ou otimização de SQL, e dashboard mostrando top queries por frequency e latency identificando candidatos para cache.

Status da decisão é aprovado e implementado desde início do projeto em 2024-Q3, com revisão prevista apenas se overhead de manter dois modelos se tornar insustentável (improvável dado benefícios claros) ou se surgir pattern superior para separação de reads e writes.

---

**Data:** 2024-09-15
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + Backend
**Última revisão:** 2025-01-05
