# ADR-005: Escolha de Multi-tenancy via Row-Level Security (RLS)

Decisão arquitetural escolhendo implementação de multi-tenancy através de Row-Level Security (RLS) nativo do PostgreSQL ao invés de databases separados ou schema-per-tenant justificada por isolamento automático e transparente de dados no database layer eliminando risco crítico de vazamento cross-tenant através de bugs em application code onde esquecimento de filtro WHERE tenant_id = X em query única pode expor dados de todas prefeituras violando LGPD e causando incidente de segurança grave, simplicidade operacional gerenciando single database com backup restore e monitoring unificados versus dezenas ou centenas de databases separados exigindo automação complexa e aumentando overhead operacional em 10x, economia de recursos com single connection pool compartilhado entre tenants otimizando uso de memória e conexões versus overhead de manter pools separados por tenant consumindo 50-100MB por database, queries cross-tenant facilitadas para analytics e reporting agregado necessários para dashboards de sistema e métricas globais que seriam extremamente complexas com databases separados exigindo federation ou ETL batch, migrations simplificadas aplicadas uma única vez no database central versus execução paralela em N databases com risco de falha parcial e inconsistência entre tenants, performance superior com shared buffer cache beneficiando queries similares entre tenants (exemplo busca de unidades por CPF) reusando páginas cacheadas versus cold cache em database separado por tenant, compliance LGPD facilitado com policies RLS auditáveis e versionadas no schema SQL versus lógica de filtragem espalhada em dezenas de services e repositories propensa a bugs e esquecimentos, e desenvolvimento acelerado com transparência de RLS permitindo código application-layer agnóstico de tenancy sem condicionais explícitas em toda query reduzindo complexidade e surface de bugs.

Row-Level Security do PostgreSQL especificamente implementa policies declarativas no schema SQL definindo regras como "usuarios só acessam registros do seu tenant" aplicadas automaticamente pelo query planner antes de retornar resultados garantindo que mesmo queries raw ou ORM bugs não conseguem bypassar isolamento, suporta policies distintas para SELECT INSERT UPDATE DELETE permitindo granularidade como "usuarios comuns só leem seu tenant mas admins globais leem todos" sem lógica condicional complexa, integra nativamente com SET SESSION AUTHORIZATION permitindo assumir identidade de tenant específico via connection string parameter simplificando implementação, e possui overhead de performance mínimo (~2-5% adicional) pois policies são compiladas no query plan e executadas como filtros WHERE nativos sem camada adicional de abstração.

Tenant isolation é garantido através de políticas RLS aplicadas em todas tabelas multi-tenant (units holders communities processes documents annotations) com policy padrão CREATE POLICY tenant_isolation ON units FOR ALL USING (tenant_id = current_setting('app.current_tenant_id')::uuid) garantindo que queries sem tenant_id correto retornam zero rows, session variable app.current_tenant_id configurada automaticamente no início de cada request através de middleware extraindo tenant de JWT token do Keycloak garantindo que toda operação subsequente respeita tenant correto, e tabelas system-wide (users roles tenants_metadata) ficam fora de RLS sendo gerenciadas via permissões tradicionais de database.

Alternativas consideradas incluem database-per-tenant (rejeitado por overhead operacional proibitivo em escala com ~100+ tenants exigindo automação complexa de provisioning backup restore monitoring além de dificultar queries cross-tenant para analytics), schema-per-tenant (rejeitado por limitação de ~1000 schemas por database do PostgreSQL inviabilizando escala futura e complicando migrations que precisam iterar todos schemas), discriminator column sem RLS (rejeitado por risco crítico de data leak através de bugs esquecidos em queries ou ORM mal configurado sendo abordagem mais vulnerável), application-level filtering (rejeitado por duplicação de lógica de filtragem em múltiplas camadas application service repository exigindo disciplina extrema da equipe e testes exhaustivos), e sharding horizontal (rejeitado por complexidade de implementação e manutenção além de dificultar features que exigem joins cross-tenant).

Consequências positivas incluem segurança robusta com garantias no database layer imunes a bugs de application code, simplicidade operacional com single database reduzindo custo de infraestrutura e DevOps, performance excelente com shared resources e cache, desenvolvimento acelerado com código application-layer limpo sem condicionais de tenancy, compliance LGPD facilitado com isolamento auditável e versionado em SQL, e escalabilidade horizontal futura possível com Citus sharding mantendo RLS policies. Consequências negativas incluem debugging mais complexo quando policies RLS causam comportamento inesperado exigindo inspeção de session variables e policies ativas, impossibilidade de restaurar single tenant de backup completo sem tooling customizado (mitigado com pg_dump com filtros), overhead de ~2-5% em todas queries devido a avaliação de policies (aceitável dado benefícios de segurança), e lock-in parcial em PostgreSQL pois migração para outro database exigiria reescrever policies como application logic.

Configuração específica escolhida habilita RLS em todas tabelas multi-tenant via ALTER TABLE table_name ENABLE ROW LEVEL SECURITY, implementa policies padrão usando current_setting('app.current_tenant_id') como discriminator, configura middleware em GEOAPI para extrair tenant_id de JWT claim e executar SET SESSION "app.current_tenant_id" = 'uuid' no início de cada request, utiliza connection pooler (PgBouncer) em transaction mode garantindo que session variables não vazam entre requests, e implementa override temporário para jobs background e migrations via SECURITY DEFINER functions permitindo operações cross-tenant autorizadas.

Status da decisão é aprovado e implementado desde início do projeto em 2024-Q3, com revisão prevista apenas se surgir limitação crítica de escala ou performance que RLS não consiga resolver (improvável dado sucesso de RLS em sistemas enterprise com milhares de tenants).

---

**Data:** 2024-09-15
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + DBA + Segurança
**Última revisão:** 2025-01-05
**Última atualização:** 2026-01-15
**Status do arquivo**: Review
