# ADR-010: Escolha de Event-Driven Architecture com Domain Events

Decisão arquitetural escolhendo arquitetura orientada a eventos usando Domain Events para comunicação assíncrona entre aggregates e bounded contexts justificada por decoupling entre componentes permitindo evolução independente onde mudanças em fluxo de aprovação não afetam módulo de notificações ou relatórios reduzindo blast radius de bugs e facilitando deployment incremental, escalabilidade melhorada processando side effects assíncronos (envio de emails geração de PDFs cálculo de estatísticas) fora do request path crítico mantendo latência de API sub-200ms conforme RNF-002 mesmo com operações pesadas, resiliência aumentada com retry automático de event handlers falhados garantindo eventual consistency onde falha temporária em envio de email não impede aprovação de processo crítico, auditoria natural onde domain events representam fatos históricos imutáveis (UnitApproved ProcessRejected HolderLinked) fornecendo audit trail completo de todas mudanças de estado business-relevant sem código adicional de logging, extensibilidade facilitada onde novos requisitos (exemplo enviar notificação ao cidadão quando unidade aprovada) são implementados adicionando novo event handler sem modificar código existente seguindo Open-Closed Principle, e preparação para eventual migração para message bus distribuído (RabbitMQ Kafka) se escala exigir processamento em workers separados embora atualmente events sejam processados in-process.

Domain Events implementados representam fatos de negócio ocorridos no passado usando naming em past tense (UnitCreatedEvent UnitApprovedEvent HolderLinkedEvent ProcessStartedEvent) contendo apenas dados essenciais do evento (aggregate ID timestamp user ID changeset minimal) evitando coupling a estado completo de aggregate, são raised dentro de aggregate root methods encapsulando lógica de quando evento deve ser disparado (exemplo Unit.Approve() raise UnitApprovedEvent apenas se validações passarem e status mudar para Approved), são published após commit bem-sucedido da transaction garantindo consistency onde events só são disparados se mudança foi persistida evitando inconsistências de event publicado mas aggregate não salvo, são handled por event handlers registrados via dependency injection permitindo múltiplos handlers para mesmo evento processando side effects independentemente (NotificationHandler AuditHandler StatisticsHandler), e falhas em handlers não afetam transaction original sendo processados em background com retry automático garantindo eventual consistency.

Infraestrutura de events utiliza MediatR INotification como abstraction permitindo publish de domain events através de interface consistente sem coupling a biblioteca específica, in-process event bus processando handlers sequencialmente em background thread pool mantendo simplicidade operacional sem necessidade de message broker externo, transactional outbox pattern opcional para garantir exactly-once delivery onde events são salvos em tabela OutboxEvents na mesma transaction do aggregate e processados por background job garantindo que events nunca são perdidos mesmo se app crashar entre commit e publish, retry policy exponencial com backoff para handlers falhados tentando até 5x antes de mover para dead-letter queue manual intervention, e idempotency tracking em handlers críticos (envio de email pagamentos) verificando se evento já foi processado antes de executar action evitando duplicação em retries.

Eventos implementados no CARF incluem UnitCreatedEvent disparado quando técnico cadastra nova unidade triggering handlers para enviar notificação ao supervisor calcular estatísticas de progresso e registrar auditoria, UnitApprovedEvent quando gestor aprova unidade triggering geração de PDF de título provisório envio de notificação ao cidadão e atualização de dashboard de métricas, HolderLinkedEvent quando titular vinculado a unidade triggering validação de CPF duplicado em outras unidades notificação de conflito se necessário e atualização de relatório de cobertura, ProcessStartedEvent quando processo de legitimação iniciado triggering criação de timeline esperada cálculo de deadline e notificação de equipes responsáveis, DocumentUploadedEvent quando documento anexado triggering OCR automático para extrair dados validação de conformidade legal e indexação para busca, e SyncCompletedEvent quando sincronização offline completada triggering resolução de conflitos notificação de pendências e atualização de métricas de uso mobile.

Alternativas consideradas incluem coupling direto chamando métodos síncronos (rejeitado por acoplar agregates e degradar performance com side effects no request path), callbacks/observers pattern (rejeitado por dificultar testabilidade e debugging de fluxo assíncrono), message bus externo desde início (RabbitMQ Kafka rejeitados por overhead operacional prematuro sendo in-process suficiente para escala atual com possibilidade de migração futura), webhooks para integração externa (rejeitado por ser inadequado para comunicação interna entre modules), e Azure Service Bus (rejeitado por vendor lock-in e custo variável preferindo open-source self-hosted se precisar de message bus futuro).

Consequências positivas incluem decoupling entre modules facilitando manutenção evolutiva e deployment independente, performance melhorada com side effects assíncronos mantendo latência baixa de API, resiliência com retry automático garantindo eventual consistency, auditoria natural através de domain events sem código adicional, extensibilidade com novos handlers adicionados sem modificar código existente, e preparação para escala futura com possibilidade de migração para message bus distribuído. Consequências negativas incluem complexidade de debugging com fluxo assíncrono exigindo tracing distribuído para entender propagação de eventos, eventual consistency introduzindo delay entre action e side effect (exemplo aprovação completa mas email enviado 5s depois) potencialmente confundindo usuários, overhead de infraestrutura de event bus mesmo simples adicionando código boilerplate de publish/subscribe, risco de event storm se handlers disparam novos eventos recursivamente exigindo design cuidadoso, e necessidade de idempotency em handlers complicando implementação de operações não naturalmente idempotent.

Implementação específica usa MediatR INotification para domain events com pipeline behavior logging todos events published, handlers implementando INotificationHandler<TEvent> registrados via dependency injection com lifetime scoped, background processing via Hangfire para retry de handlers falhados com exponential backoff, correlation IDs propagados de request original para event handlers permitindo tracing distribuído, e monitoring de events no Application Insights com métricas de latency de handlers failure rate e retry count.

Event sourcing não é implementado mantendo traditional CRUD com domain events para side effects apenas, sendo suficiente para requisitos atuais com audit trail via soft deletes e event log, mas arquitetura permite migration futura para event sourcing se compliance exigir immutable audit trail completo.

Status da decisão é aprovado e implementado desde início do projeto em 2024-Q3, com revisão prevista se complexidade de eventual consistency se tornar problemática para UX (improvável com delays típicos de <5s) ou se escala exigir migration para message bus externo distribuído (planejado para >50k usuarios ativos mensais).

## Implementação

Decisão implementada no backend [GEOAPI Domain Layer](../../../PROJECTS/GEOAPI/DOCS/ARCHITECTURE/01-overview.md) publicando Domain Events (UnitCreatedEvent, LegitimationApprovedEvent) após persistir agregados permitindo comunicação assíncrona entre aggregates desacoplados conforme [Clean Architecture pattern](./ADR-008-clean-architecture-ddd.md), handlers de eventos registrados via MediatR executando side effects como envio de notificações ou atualização de caches, audit logging intercepta events gravando em [audit_logs table](../../../PROJECTS/GEOAPI/DOCS/CONCEPTS/04-audit-logging.md) capturando quem/quando/o_que para compliance, futura integração com message broker (RabbitMQ/Kafka) permitirá eventos distribuídos entre microsserviços.

---

**Data:** 2024-09-15
**Status:** Aprovado e Implementado
**Decisor:** Equipe de Arquitetura + Backend
**Última revisão:** 2025-01-05
