# Arquitetura de Autenticação Keycloak

Sistema CARF utiliza Keycloak como provedor centralizado de autenticação e autorização implementando padrões OAuth2 e OpenID Connect para seis aplicações sendo GEOWEB REURBCAD GEOAPI GEOGIS WEBDOCS e ADMIN com SSO automático Single Sign-On permitindo login único que propaga sessão entre todas aplicações via cookie de sessão Keycloak onde usuário autentica em qualquer aplicação e automaticamente fica autenticado nas demais sem necessidade de reentrada de credenciais com logout centralizado Single Logout que invalida sessão Keycloak e desloga usuário de todos aplicativos simultaneamente garantindo segurança. OAuth2 define framework de autorização especificando o que usuário pode fazer através de scopes e permissions enquanto OpenID Connect OIDC estende OAuth2 adicionando camada de autenticação definindo quem é o usuário através de id_token JWT contendo claims de identidade como sub subject identificador único name email preferred_username e custom claims tenant_id current_tenant allowed_tenants roles configurados via protocol mappers no realm Keycloak. Fluxo típico de autenticação inicia quando usuário acessa aplicação GEOWEB sem token válido sendo redirecionado para endpoint de autorização Keycloak com parâmetros response_type code indicando Authorization Code flow, client_id identificando aplicação GEOWEB, redirect_uri para callback após login, scope openid profile email tenant solicitando claims específicos, state random para CSRF protection, code_challenge hash SHA256 do code_verifier para PKCE Proof Key for Code Exchange garantindo segurança mesmo em public clients sem client_secret, e code_challenge_method S256 indicando algoritmo de hash utilizado. Usuário visualiza tela de login Keycloak customizada com tema CARF em português brasileiro contendo logo sistema campos username password botão entrar link esqueci senha e validações client-side CPF/CNPJ via JavaScript tscore library, insere credenciais válidas que são verificadas contra database PostgreSQL backend do Keycloak aplicando password policy enforcement mínimo oito caracteres incluindo dígito lowercase uppercase caractere especial e brute force protection bloqueando após cinco tentativas por quinze minutos, autenticação bem-sucedida gera authorization code único de uso único válido por sessenta segundos associado ao code_challenge enviado anteriormente, Keycloak redireciona browser de volta para redirect_uri da aplicação GEOWEB incluindo query parameters code contendo authorization code e state para validação CSRF. Aplicação GEOWEB recebe callback extrai code e state valida que state corresponde ao enviado anteriormente prevenindo ataques CSRF, executa POST request para token endpoint do Keycloak enviando grant_type authorization_code, code recebido no callback, redirect_uri mesmo utilizado anteriormente para validação, client_id identificação da aplicação, e code_verifier valor original não hasheado correspondente ao code_challenge enviado no início do fluxo permitindo Keycloak validar que SHA256 de code_verifier corresponde ao code_challenge armazenado garantindo que requisição de token vem da mesma aplicação que iniciou fluxo impedindo authorization code interception attacks. Keycloak valida todos parâmetros verifica que code_verifier quando hasheado com SHA256 produz code_challenge original confirma que redirect_uri e client_id correspondem aos utilizados na autorização inicial checa que authorization code ainda é válido não expirou e não foi usado anteriormente garantindo uso único, validações bem-sucedidas resultam em resposta JSON contendo access_token JWT assinado com private key Keycloak válido por cinco minutos usado para autorizar chamadas API backend incluindo claims padrão iss issuer identificando Keycloak sub subject ID único usuário exp expiration timestamp iat issued at aud audience especificando aplicação destinatária junto com custom claims tenant_id string UUID do tenant atualmente selecionado extraído de current_tenant user attribute, allowed_tenants array JSON contendo lista de UUIDs de todos tenants aos quais usuário tem permissão acesso extraído de tenants user attribute multivalued, roles array contendo roles do usuário como field-collector analyst admin super-admin extraídos de realm roles e client roles, além de id_token JWT contendo informações de identidade do usuário como sub name email preferred_username tenant_id allowed_tenants usado pelo frontend para exibir informações de perfil e UI personalizada, e refresh_token opaque string válido por período mais longo default trinta dias configurado com max reuse zero garantindo one-time-use onde cada uso de refresh token retorna novo access_token E novo refresh_token invalidando anterior prevenindo replay attacks caso refresh token seja interceptado. Aplicação GEOWEB armazena tokens de forma segura access_token e id_token em memória volatile state nunca em localStorage por risco XSS cross-site scripting e refresh_token em httpOnly secure cookie inacessível por JavaScript protegendo contra ataques client-side, utiliza access_token em todas requisições HTTP para backend GEOAPI incluindo header Authorization Bearer seguido do token JWT permitindo backend validar autenticidade e extrair claims sem necessidade de consultar Keycloak a cada request devido natureza self-contained de JWTs. Backend GEOAPI recebe requisição HTTP com Authorization header extrai token JWT valida assinatura digital usando public key do Keycloak obtida via JWKS JSON Web Key Set endpoint cache das chaves públicas permitindo validação offline sem comunicação com Keycloak melhorando performance e resiliência, verifica claims obrigatórios como exp expiration garantindo token não expirou comparando timestamp atual, iss issuer confirmando que token foi emitido pelo Keycloak esperado prevenindo token substitution attacks, aud audience validando que token foi emitido para esta API específica impedindo token replay entre diferentes sistemas, validações bem-sucedidas permitem extração de claims customizados tenant_id allowed_tenants roles que são utilizados para autorização granular e isolamento multi-tenant. Middleware de autenticação no backend .NET ASP.NET Core extrai claim tenant_id do JWT validando que valor é UUID válido não nulo, executa comando SQL SET LOCAL app.tenant_id igual ao tenant_id extraído configurando variável de sessão PostgreSQL específica para conexão atual request-scoped garantindo isolamento entre requisições concorrentes mesmo compartilhando connection pool, todas tabelas do database possuem Row Level Security policies RLS definidas como CREATE POLICY tenant_isolation ON nome_tabela USING tenant_id igual a current_setting app.tenant_id true convertido para UUID filtrando automaticamente todas queries SELECT UPDATE DELETE permitindo acesso apenas a rows onde tenant_id da row corresponde ao tenant_id setado na sessão PostgreSQL, garantindo isolamento absoluto de dados entre tenants mesmo em caso de SQL injection ou bugs na aplicação porque filtragem ocorre na camada de banco de dados abaixo da aplicação impossibilitando bypass. Multi-tenancy dinâmico permite usuários pertencerem a múltiplos tenants simultaneamente através de user attribute tenants array multivalued contendo lista de tenant IDs autorizados como prefeitura-a prefeitura-b prefeitura-c e user attribute current_tenant string indicando tenant atualmente ativo selecionado pelo usuário no frontend, protocol mappers configurados no client Keycloak extraem esses attributes e os incluem como claims JWT sendo tenant_id claim tipo String mapeado de current_tenant attribute incluído em id_token access_token e userinfo endpoint, e allowed_tenants claim tipo JSON mapeado de tenants attribute multivalued também incluído em todos tokens permitindo frontend validar operações de troca de tenant antes de chamar backend. Frontend renderiza tenant switcher dropdown somente se allowed_tenants claim contém mais de um tenant indicando usuário multi-tenant, dropdown lista todos tenants permitidos usando nomes amigáveis obtidos via API endpoint que resolve UUIDs para nomes como Prefeitura Municipal de São Paulo consultando tabela tenants, usuário seleciona tenant diferente do atual acionando função que chama endpoint POST /api/auth/switch-tenant enviando novo tenant_id no body da requisição, backend valida que tenant_id solicitado está presente no allowed_tenants claim do access_token atual prevenindo privilege escalation onde usuário tenta trocar para tenant não autorizado retornando erro 403 Forbidden caso validação falhe, validação bem-sucedida aciona chamada Keycloak Admin API usando client credentials flow onde backend GEOAPI autentica como service account com client_id geoapi-admin e client_secret protegido obtendo admin access_token, utiliza Admin API para atualizar user attributes via PUT /admin/realms/carf/users/user-id setando current_tenant para novo valor selecionado persistindo escolha do usuário, retorna resposta success para frontend que executa keycloak.updateToken com minValidity alto forçando refresh do access_token, refresh token flow retorna novo access_token com tenant_id claim atualizado refletindo novo current_tenant, frontend recarrega página ou re-fetches dados usando novo token que agora possui tenant_id diferente resultando em backend setando app.tenant_id PostgreSQL para novo valor e RLS policies filtrando dados do novo tenant automaticamente completando troca de contexto transparente. Fluxo Client Credentials utilizado por aplicação GEOGIS plugin QGIS executando server-to-server authentication sem contexto de usuário humano, plugin configurado como confidential client com service accounts enabled possuindo client_id geogis e client_secret armazenado de forma segura em QSettings encrypted do QGIS, executa POST request diretamente para token endpoint Keycloak enviando grant_type client_credentials, client_id geogis, client_secret valor secreto, e scope opcional especificando permissões desejadas, Keycloak valida credenciais do client verificando client_secret contra hash armazenado aplicando mesma segurança de password hashing, validação bem-sucedida retorna access_token JWT sem contexto de usuário contendo claims client_id geogis, allowed-origins configurados, resource_access com roles específicos do service account como gis-reader gis-writer definidos em Service Account Roles no Keycloak Admin Console, token válido por cinco minutos usado pelo plugin para autenticar requisições WFS WMS para GEOAPI backend que valida token extraindo client_id e roles autorizando operações GIS baseado em permissões do service account sem necessidade de login interativo usuário. Bearer token validation no backend GEOAPI implementada via middleware ASP.NET Core Authentication com AddJwtBearer configurando TokenValidationParameters especificando ValidateIssuerSigningKey true exigindo validação de assinatura digital, IssuerSigningKeyResolver delegate que consulta JWKS endpoint do Keycloak /.well-known/openid-configuration seguido por jwks_uri obtendo public keys RSA usadas para assinar tokens com cache de chaves por vinte e quatro horas renovando automaticamente em caso de key rotation, ValidIssuer definido como URL do Keycloak realm garantindo tokens vieram do issuer esperado, ValidAudience especificando client_id da API como geoapi validando que token foi emitido para esta audiência específica, ValidateLifetime true verificando que token não expirou comparando exp claim com timestamp atual considerando ClockSkew de cinco minutos permitindo pequena diferença de relógio entre servidores, RequireExpirationTime true exigindo presença de exp claim impedindo tokens sem expiração, validações bem-sucedidas populam HttpContext.User ClaimsPrincipal contendo todos claims do JWT acessíveis via User.FindFirst ou User.Claims permitindo controllers extraírem tenant_id roles preferred_username para lógica de autorização, middleware de autorização subsequente verifica roles usando attributes [Authorize Roles = "admin,analyst"] ou policy-based authorization configurando policies no AddAuthorization como RequireAdminRole que verifica presença de role admin ou super-admin em roles claim do token permitindo controle granular de acesso por endpoint ou ação específica. Sessão Keycloak configurada com SSO Session Idle timeout de trinta minutos equivalente a mil e oitocentos segundos definindo período de inatividade após o qual sessão expira exigindo reautenticação, SSO Session Max lifespan de dez horas equivalente a trinta e seis mil segundos definindo duração máxima absoluta de sessão independente de atividade forçando relogin após esse período mesmo com uso ativo mitigando risco de session hijacking prolongado, Client Session Idle e Client Session Max configurados similarmente aplicando timeouts específicos por client permitindo granularidade, Remember Me habilitado estende idle timeout para vinte e quatro horas quando usuário marca checkbox lembrar-me no login criando persistent session cookie que sobrevive fechamento do browser mantendo usuário logado por período estendido conveniente para dispositivos pessoais seguros. Refresh token strategy configurada com Refresh Token Max Reuse zero garantindo one-time-use onde cada uso de refresh token via POST /token grant_type refresh_token invalida refresh token anterior e emite novo prevenindo scenarios onde atacante intercepta refresh token e consegue utilizá-lo repetidamente, Revoke Refresh Token habilitado permite invalidação manual via Admin API ou logout, Refresh Token Lifespan de trinta dias permite renovação de sessão sem relogin desde que usuário utilize aplicação dentro de janela de trinta dias, access token lifetime curto de cinco minutos força aplicações renovarem tokens frequentemente via refresh token flow reduzindo janela de exposição em caso de access token leak pois mesmo que atacante intercepte access token ele expira rapidamente tornando inútil após cinco minutos enquanto refresh token mais longo permite sessões persistentes sem comprometer segurança.

---

**Última atualização:** 2026-01-10
**Status do arquivo**: Pronto
