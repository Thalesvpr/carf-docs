# Multi-Tenancy Dinâmico

Estratégia: 1 realm "carf" + atributos `tenants: ["prefeitura-a", "prefeitura-b"]` e `current_tenant: "prefeitura-a"` no usuário → protocol mapper converte pra JWT claims `tenant_id` e `allowed_tenants` → frontend React tem TenantSwitcher component renderizando `<select>` com `user.allowed_tenants.map(t => <option value={t.id}>{t.name}</option>)` → onChange chama `switchTenant(tenantId)` que faz `await api.post('/api/auth/switch-tenant', { tenantId })` → backend .NET valida se `tenantId` está em `User.FindFirst("allowed_tenants")?.Value.Split(',')` → se sim, chama `await keycloakAdmin.Users.UpdateAttribute(userId, "current_tenant", tenantId)` usando Keycloak.Net library → frontend faz `await keycloak.updateToken(5)` pegando novo token → `window.location.reload()` pra recarregar app com novo contexto → middleware backend `TenantMiddleware` extrai `context.User.FindFirst("tenant_id")?.Value` e executa `await db.Database.ExecuteSqlRawAsync("SET LOCAL app.tenant_id = {0}", tenantId)` → PostgreSQL RLS policy `CREATE POLICY tenant_isolation ON units USING (tenant_id = current_setting('app.tenant_id', true)::uuid)` filtra automaticamente todos os SELECTs, INSERTs, UPDATEs, DELETEs garantindo isolamento total. Alternativas rejeitadas: 1 realm por tenant (não escala, SSO não funciona entre realms), 1 realm + grupos (usuário só pode estar em 1 grupo, consultores multi-tenant não funciona). Casos de uso: analista 1 tenant (não vê dropdown), consultor N tenants (vê dropdown e troca livremente), super-admin (pode trocar pra qualquer tenant através de endpoint especial que não valida allowed_tenants se role = super-admin).

---

**Última atualização:** 2026-01-09
**Status do arquivo**: Review
