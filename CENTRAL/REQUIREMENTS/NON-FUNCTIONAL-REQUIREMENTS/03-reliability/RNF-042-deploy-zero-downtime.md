---
modules: [GEOAPI, GEOWEB, REURBCAD, GEOGIS]
epic: performance
---

# RNF-042: Zero Downtime Deployment

O sistema GEOAPI deve suportar deploys de novas versões sem causar downtime perceptível aos usuários, utilizando estratégias de rolling update em ambientes Kubernetes onde novas versões de containers são gradualmente introduzidas enquanto versões antigas continuam servindo requisições até que todos os novos pods estejam saudáveis e prontos para tráfego. A implementação de rolling update no Kubernetes deve configurar parâmetros adequados na deployment spec, incluindo maxSurge definindo quantos pods adicionais podem ser criados durante o update (tipicamente 25% para balancear velocidade e uso de recursos), maxUnavailable especificando quantos pods podem estar indisponíveis simultaneamente (tipicamente 0 para zero downtime), e strategyType como RollingUpdate ao invés de Recreate que causaria downtime ao destruir todos os pods antes de criar novos. Os health checks antes de rotear tráfego são críticos e devem incluir readiness probes que verificam se o container está pronto para receber tráfego, testando endpoints como /health ou /ready que validam conectividade com banco de dados, disponibilidade de dependências externas e conclusão de inicialização, com o Kubernetes só direcionando tráfego para pods que passam consistentemente no readiness probe, além de liveness probes que detectam quando um container entrou em estado irrecuperável e precisa ser reiniciado. O rollback automático se falhar deve ser implementado através de monitoramento pós-deployment que detecta aumentos anormais em error rates, latência de resposta ou falhas em health checks, disparando automaticamente um rollback para a versão anterior estável utilizando comandos como kubectl rollout undo, com thresholds configuráveis como mais de 5% de error rate por 2 minutos consecutivos ou mais de 50% de pods falhando em readiness checks. As migrações de banco de dados devem ser cuidadosamente planejadas para compatibilidade com rolling updates, utilizando estratégias como migrações apenas aditivas durante o deploy (adicionando colunas como nullable, criando novas tabelas), executando a migração antes do deploy da aplicação para que versões antigas tolerem o novo schema, e apenas em deploys subsequentes removendo código que usa schema antigo e opcionalmente removendo colunas/tabelas deprecated, garantindo que em qualquer momento durante o rolling update, tanto versões antigas quanto novas da aplicação podem operar com o mesmo schema de banco. Os critérios de aceitação incluem a verificação de que deploys ocorrem via rolling update com configuração documentada de maxSurge e maxUnavailable, que readiness probes estão implementados e testados para todos os endpoints críticos, que o sistema detecta automaticamente falhas de deployment através de métricas e dispara rollback quando necessário, que durante testes de deployment não há retorno de erros 5xx para clientes e latência não aumenta significativamente, e que migrações de banco de dados seguem padrão de compatibilidade com múltiplas versões simultâneas. Este requisito é should-have por melhorar significativamente a disponibilidade e permitir deploys frequentes sem impacto nos usuários, facilitando práticas de continuous deployment e reduzindo o risco associado a releases, embora adicione complexidade ao processo de deployment e requeira disciplina no design de migrações de banco de dados e versionamento de APIs.
