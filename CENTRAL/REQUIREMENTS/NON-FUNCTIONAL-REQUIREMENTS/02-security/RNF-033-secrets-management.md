---
modules: [GEOAPI]
epic: security
---

# RNF-033: Secrets Management

O sistema GEOMAP5 deve gerenciar secrets sensíveis como senhas de banco de dados, chaves de API de serviços externos, certificados SSL e tokens de integração através de mecanismos seguros que impedem exposição acidental em código fonte, logs ou ambientes de desenvolvimento, utilizando variáveis de ambiente como baseline mínimo e sistemas especializados de gerenciamento de secrets como HashiCorp Vault ou AWS Secrets Manager em ambientes de produção. Nenhum secret deve jamais ser hardcoded diretamente no código fonte da aplicação ou em arquivos de configuração versionados no Git, onde mesmo commits antigos podem revelar credenciais que permanecem válidas, exigindo rotação imediata se exposição for detectada. Em ambientes de desenvolvimento local, desenvolvedores devem utilizar arquivos .env não versionados (incluídos em .gitignore) para armazenar secrets, com arquivo .env.example versionado contendo apenas nomes de variáveis e valores de exemplo não-sensíveis que documentam quais secrets são necessários. Em ambientes de staging e produção executando em Kubernetes, secrets devem ser injetados como variáveis de ambiente ou volumes montados através de Kubernetes Secrets ou integrações com sistemas externos de gerenciamento como Vault, onde secrets são criptografados em repouso no etcd e descriptografados apenas em memória nos pods que necessitam deles. HashiCorp Vault quando utilizado deve fornecer capacidades avançadas como geração dinâmica de credenciais de banco de dados com tempo de vida limitado, rotação automática de secrets, controle de acesso granular baseado em políticas, auditoria completa de acesso a secrets e capacidade de revogar acesso imediatamente em caso de comprometimento. Rotação periódica de secrets deve ser implementada com frequência baseada em criticidade, onde senhas de banco de dados de produção devem ser rotacionadas trimestralmente, API keys de serviços externos semestralmente, e certificados SSL antes de expiração com renovação automática via Let's Encrypt quando possível. O processo de rotação deve ser planejado para zero-downtime, utilizando estratégias como manter duas versões de credencial válidas simultaneamente durante período de transição, permitindo que pods antigos continuem funcionando enquanto novos pods utilizam credencial atualizada. Acesso a secrets em sistemas de gerenciamento deve ser restrito através de princípio de menor privilégio, onde desenvolvedores não devem ter acesso direto a secrets de produção, apenas administradores de operações autorizados, com todos os acessos registrados em logs de auditoria. Secrets nunca devem aparecer em logs de aplicação, stdout/stderr de containers ou mensagens de erro apresentadas a usuários, exigindo sanitização cuidadosa de outputs e configuração de redactors em sistemas de logging. Ferramentas de scanning de código como git-secrets ou truffleHog devem ser integradas em pipelines de CI/CD para detectar acidentalmente commits contendo patterns que pareçam secrets, bloqueando merge até que sejam removidos. Este requisito é Must-have pois exposição de secrets é uma das causas mais comuns e facilmente exploráveis de comprometimento de sistemas, onde credenciais vazadas permitem acesso total a recursos críticos independentemente de outras medidas de segurança implementadas.
**Última atualização:** 2026-01-15
**Status do arquivo**: Pronto
