---
modules: [GEOAPI, GEOWEB, REURBCAD, GEOGIS]
epic: performance
---

# RNF-045: Validação de Integridade

O sistema GEOAPI deve implementar múltiplas camadas de validação de integridade de dados críticos para garantir consistência, precisão e confiabilidade das informações armazenadas, prevenindo corrupção de dados, inconsistências relacionais e erros de geometrias espaciais que poderiam comprometer a qualidade dos dados de regularização fundiária. As constraints de foreign key no banco de dados PostgreSQL devem ser definidas para todas as relações entre tabelas, garantindo integridade referencial onde registros filhos não podem existir sem seus pais correspondentes, por exemplo unit_id em tabela de fotos deve referenciar units(id) com ON DELETE CASCADE ou ON DELETE RESTRICT dependendo da semântica desejada, holder_id deve referenciar holders(id), community_id deve referenciar communities(id), e tenant_id deve referenciar tenants(id), com índices apropriados criados automaticamente nas colunas de foreign key para otimizar performance de joins e verificações de integridade. A validação de geometrias PostGIS é crítica para dados geoespaciais e deve incluir verificação de que todas as geometrias são válidas segundo o modelo Simple Features do OGC utilizando funções como ST_IsValid() antes de inserção, com triggers de banco de dados que automaticamente rejeitam geometrias inválidas ou opcionalmente tentam corrigi-las usando ST_MakeValid(), garantindo que polígonos não tenham auto-intersecções, que rings externos sejam orientados corretamente (counter-clockwise) e rings internos (holes) sejam clockwise, que coordenadas estejam dentro dos limites válidos para o SRID especificado, e que o tipo de geometria seja consistente com o esperado para cada coluna (POINT para coordenadas de marcadores, POLYGON ou MULTIPOLYGON para limites de unidades habitacionais). Os checksums de arquivos devem ser calculados e armazenados para todos os uploads de fotos e documentos, utilizando algoritmos como SHA-256 ou MD5 para gerar hash único do conteúdo do arquivo no momento do upload, armazenando este checksum em coluna dedicada na tabela de metadados, e opcionalmente verificando periodicamente a integridade dos arquivos no object storage através de job em background que recalcula checksums e compara com valores armazenados, detectando corrupção silenciosa de dados que pode ocorrer em sistemas de storage distribuído. As validações adicionais devem incluir constraints de unique para prevenir duplicação acidental de registros críticos, constraints de check para garantir que valores estejam em ranges válidos (por exemplo área de unidade habitacional deve ser positiva e menor que 10000 metros quadrados), constraints de not null em campos essenciais para garantir que informações críticas sempre sejam fornecidas, e validações de formato para campos como CPF, CNPJ, CEP e email utilizando expressões regulares ou funções de validação customizadas. Os critérios de aceitação incluem a definição de foreign key constraints em todas as relações entre tabelas com política de DELETE apropriada documentada, a validação automática de geometrias usando ST_IsValid() antes de inserção ou atualização com rejeição de geometrias inválidas, o cálculo e armazenamento de checksums SHA-256 para todos os arquivos uploaded com processo de verificação periódica, a implementação de constraints adicionais (unique, check, not null) em campos críticos conforme regras de negócio, e testes automatizados que verificam que violações de integridade são corretamente detectadas e rejeitadas pelo sistema. Este requisito é must-have por ser fundamental para confiabilidade dos dados em sistema de regularização fundiária onde inconsistências ou corrupção de informações cadastrais poderiam ter implicações legais sérias, além de prevenir cascata de erros onde dados inválidos em camadas inferiores se propagam e causam problemas difíceis de diagnosticar em camadas superiores da aplicação.
